# Low Code 1 – Einführung & Grundlagen

!!! abstract "Lernziele"
    Nach diesem Kapitel kannst du …

    - Was **Low Code** und **No Code** sind und unterscheiden.
    - Die **Vorteile und Nachteile** von Low Code verstehen.
    - **Anwendungsfälle** für Low Code erkennen.
    - **Populäre Plattformen** kennenlernen.
    - Eine einfache **Anwendung** mit Low Code erstellen.

---

## Einführung

**Low Code** ist eine Entwicklungsmethode, die **wenig oder gar keinen Programmiercode** benötigt, um Anwendungen zu erstellen. Stattdessen werden **visuelle Editoren**, **Drag-and-Drop** und **Konfiguration** verwendet.

![Low Code Logo](https://upload.wikimedia.org/wikipedia/commons/thumb/7/7d/Automation.svg/300px-Automation.svg.png){ align=left width=300px }

**Wichtige Fakten:**
- Low Code wurde populär durch **OutSystems** (2001) und **Mendix** (2005)
- Der Markt wächst jährlich um **20-30%**
- Erwartet wird, dass bis **2025 70%** neuer Anwendungen mit Low Code entwickelt werden
- **Citizen Developers** (Nicht-Programmierer) können Anwendungen bauen

**Unterschiede:**
- **Low Code**: Wenig Code, visuelle Entwicklung, IT-Experten
- **No Code**: Kein Code, rein visuell, Business-Anwender

---

## Was ist Low Code?

### Definition
Low Code ist eine **Entwicklungsplattform**, die:
- **Visuelle Modellierung** von Logik und UI ermöglicht
- **Automatisches Code-Generierung** im Hintergrund
- **Wiederverwendbare Komponenten** bietet
- **Integrationen** mit externen Systemen vereinfacht
- **Schnelle Prototypen** und Iterationen erlaubt

### Architektur
```
Visuelle Oberfläche → Modell → Generator → Code → Deployment
```

**Komponenten:**
- **Drag-and-Drop-Editor**: UI-Komponenten platzieren
- **Workflow-Designer**: Geschäftslogik modellieren
- **Datenmodell-Editor**: Datenbanken definieren
- **Integration-Builder**: APIs und Services verbinden

---

## Low Code vs. No Code

| Aspekt | Low Code | No Code |
|--------|----------|---------|
| **Zielgruppe** | IT-Experten, Entwickler | Business-Anwender, Citizen Developers |
| **Flexibilität** | Hoch (Code optional) | Mittel (visuell) |
| **Komplexität** | Komplexe Anwendungen | Einfache Anwendungen |
| **Beispiele** | OutSystems, Mendix | Bubble, Webflow, Airtable |
| **Code-Export** | Möglich | Nicht möglich |
| **Skalierbarkeit** | Hoch | Begrenzt |

---

## Vorteile von Low Code

### 1. Schnelleres Development
- **70-90%** schneller als traditionelles Coding
- Sofortige Visualisierung von Ergebnissen
- Schnelle Iterationen und Anpassungen

### 2. Geringere Kosten
- Weniger Entwickler-Stunden nötig
- Geringere Einarbeitungszeit
- Wiederverwendbare Komponenten

### 3. Höhere Produktivität
- Entwickler fokussieren sich auf Logik, nicht auf Boilerplate
- Parallelarbeit durch visuelle Modellierung
- Schnelles Prototyping

### 4. Democratization of IT
- Business-Anwender können Lösungen bauen
- Weniger Abhängigkeit von IT-Abteilung
- Schnelle Reaktion auf Anforderungen

### 5. Qualität & Standards
- Automatische Code-Generierung folgt Best Practices
- Weniger Fehler durch visuelle Validierung
- Konsistente Architektur

---

## Nachteile & Risiken

### 1. Vendor Lock-in
- Abhängigkeit von Plattform-Anbieter
- Wechsel zu anderer Plattform schwierig
- Langfristige Kosten durch Lizenzen

### 2. Flexibilitätsgrenzen
- Komplexe Logik kann schwierig sein
- Spezielle Anforderungen vielleicht nicht umsetzbar
- Performance-Optimierung begrenzt

### 3. Skalierbarkeit
- Große Anwendungen werden schnell unübersichtlich
- Performance bei hohen Lasten fraglich
- Technische Schulden können wachsen

### 4. Wartung & Debugging
- Fehlersuche in visuellen Modellen schwierig
- Versionierung komplexer als Code
- Dokumentation oft unzureichend

### 5. Qualitätssicherung
- Automatisierte Tests schwierig
- Code-Review nicht möglich
- Sicherheitsaudit komplex

---

## Anwendungsfälle

### 1. Business-Apps
- **CRM-Systeme**: Kundenverwaltung, Verkaufstracking
- **ERP-Module**: Bestellmanagement, Lagerverwaltung
- **HR-Tools**: Bewerbermanagement, Mitarbeiterportale

### 2. Prototyping & MVPs
- Schnelle Ideenvalidierung
- Kundenfeedback sammeln
- Investoren-Pitches

### 3. Workflow-Automatisierung
- Genehmigungsprozesse
- Formular-basierte Workflows
- Benachrichtigungen und Alerts

### 4. Daten-Integration
- Dashboards und Reporting
- Daten-Synchronisation
- API-Integrationen

### 5. Interne Tools
- Admin-Panels
- Helpdesk-Systeme
- Projektmanagement-Tools

### Nicht geeignet:
- **High-Performance-Anwendungen** (Echtzeit, Big Data)
- **Komplexe Algorithmen** (KI, Machine Learning)
- **Sicherheitskritische Systeme** (Banking, Medizin)
- **Mobile Apps mit nativer Performance**

---

## Populäre Plattformen

### Enterprise Low Code

#### 1. **OutSystems**
- **Fokus**: Enterprise-Apps, Mobile, Web
- **Vorteile**: Hohe Flexibilität, starke Integration
- **Nachteile**: Teuer, komplexe Lizenzierung
- **Preis**: Ab ~€10.000/Jahr

#### 2. **Mendix (Siemens)**
- **Fokus**: Enterprise, IoT, Manufacturing
- **Vorteile**: Starke BPM-Integration, Skalierbarkeit
- **Nachteile**: Steile Lernkurve
- **Preis**: Ab ~€5.000/Jahr

#### 3. **Microsoft Power Apps**
- **Fokus**: Office 365 Integration, SharePoint
- **Vorteile**: Gute Microsoft-Integration, günstig
- **Nachteile**: Eingeschränkte Flexibilität
- **Preis**: Ab ~€10/Benutzer/Monat

### No Code / Citizen Developer

#### 4. **Bubble**
- **Fokus**: Web-Apps, Startups
- **Vorteile**: Sehr flexibel, große Community
- **Nachteile**: Vendor Lock-in, Performance
- **Preis**: Ab ~€30/Monat

#### 5. **Webflow**
- **Fokus**: Webseiten, Landing Pages
- **Vorteile**: Design-orientiert, SEO-friendly
- **Nachteile**: Keine komplexe Logik
- **Preis**: Ab ~€15/Monat

#### 6. **Airtable**
- **Fokus**: Datenbank-Apps, Collaboration
- **Vorteile**: Einfach, mächtige Datenbank
- **Nachteile**: Keine komplexe UI
- **Preis**: Ab ~€12/Monat

#### 7. **AppSheet (Google)**
- **Fokus**: Mobile Apps, Daten-Integration
- **Vorteile**: Gute Google-Integration
- **Nachteile**: Eingeschränkte Anpassung
- **Preis**: Ab ~€5/Benutzer/Monat

---

## Praktisches Beispiel: CRM mit Low Code

### Schritt 1: Datenmodell
```
Kunden (Tabelle)
├── ID (Primary Key)
├── Name (Text)
├── Email (Text)
├── Telefon (Text)
├── Status (Dropdown: Neu, Aktiv, Inaktiv)
└── Erstelldatum (Datum)

Interaktionen (Tabelle)
├── ID (Primary Key)
├── Kunden-ID (Foreign Key)
├── Typ (Dropdown: Anruf, Email, Meeting)
├── Notiz (Text)
└── Datum (Datum)
```

### Schritt 2: UI-Design
- **Dashboard**: Übersicht aller Kunden
- **Detailansicht**: Einzelner Kunde mit Interaktionshistorie
- **Formular**: Neuen Kunden erfassen
- **Suche**: Kunden finden

### Schritt 3: Logik
- **Workflow**: Bei neuem Kunden → Email an Vertrieb
- **Validierung**: Email muss einzigartig sein
- **Benachrichtigung**: Bei Status-Änderung

### Schritt 4: Integrationen
- **Email**: SMTP für Benachrichtigungen
- **API**: Verbindung zu ERP-System
- **Export**: CSV/Excel für Reports

---

## Low Code in der Praxis

### Beispiel 1: Approval Workflow (Power Apps)
```plaintext
1. Formular: Mitarbeiter beantragt Urlaub
2. Logik: Wenn Tage > 5 → Genehmigung durch Manager
3. Benachrichtigung: Email an Mitarbeiter
4. Integration: Sync mit Outlook Kalender
```

### Beispiel 2: Customer Portal (OutSystems)
```plaintext
1. Login: Authentifizierung via Active Directory
2. Dashboard: Bestellungen, Rechnungen, Support-Tickets
3. Self-Service: Passwort-Reset, Adressänderung
4. Integration: SAP Backend, Payment Gateway
```

### Beispiel 3: MVP für Startup (Bubble)
```plaintext
1. Landing Page: Marketing, Features
2. User Registration: Email, Passwort
3. Core Feature: Produkt-Konfigurator
4. Payment: Stripe Integration
5. Launch: In 2 Wochen statt 6 Monaten
```

---

## Best Practices

### 1. Klare Anforderungen
- Definiere **Scope** und **Ziele**
- Identifiziere **Key Features**
- Priorisiere **MVP** (Minimum Viable Product)

### 2. Datenmodellierung
- Normalisiere Daten
- Definiere Beziehungen
- Plane für Skalierbarkeit

### 3. UI/UX Design
- Konsistente Design-Systeme
- Mobile-First Ansatz
- Barrierefreiheit

### 4. Integrationen
- Dokumentiere APIs
- Implementiere Fehlerbehandlung
- Teste mit echten Daten

### 5. Sicherheit
- Role-Based Access Control (RBAC)
- Datenverschlüsselung
- Audit-Logging

### 6. Wartung
- Dokumentation
- Versionierung
- Regelmäßige Reviews

---

## Entscheidungshilfe: Low Code oder Full Code?

### Low Code wählen, wenn:
- ✅ Schnelle Time-to-Market wichtig ist
- ✅ Anwendung eher standardisiert ist
- ✅ Ressourcen knapp sind
- ✅ Business-Anwender beteiligt sind
- ✅ Prototyping oder MVP

### Full Code wählen, wenn:
- ✅ Hohe Performance erforderlich ist
- ✅ Komplexe Logik nötig ist
- ✅ Volle Kontrolle über Code benötigt wird
- ✅ Langfristige Skalierbarkeit geplant ist
- ✅ Sicherheitskritische Anwendung

### Hybrid-Ansatz:
- **Low Code** für UI und Standard-Logik
- **Custom Code** für komplexe Business-Logik
- **APIs** für Integrationen

---

## Häufige Fehler & Fallstricke

### Fehler 1: Zu komplexe Anwendungen
- **Problem**: Low Code wird für alles verwendet
- **Lösung**: Klare Grenzen setzen, Full Code für komplexe Teile

### Fehler 2: Vendor Lock-in ignorieren
- **Problem**: Späterer Wechsel sehr teuer
- **Lösung**: Export-Möglichkeiten prüfen, Datenportabilität

### Fehler 3: Keine Governance
- **Problem**: Shadow IT, unkontrollierte Anwendungen
- **Lösung**: Zentrale IT-Governance etablieren

### Fehler 4: Zu schnelles Wachstum
- **Problem**: Anwendung wird unübersichtlich
- **Lösung**: Modularer Aufbau, regelmäßige Refactorings

### Fehler 5: Qualität ignorieren
- **Problem**: Keine Tests, keine Dokumentation
- **Lösung**: Qualitätsstandards definieren und durchsetzen

---

## Zusammenfassung & Checkliste

### Wichtige Konzepte
- ✅ **Low Code**: Visuelle Entwicklung mit optionaler Code-Erweiterung
- ✅ **No Code**: Reine visuelle Entwicklung
- ✅ **Vorteile**: Schneller, günstiger, democratisiert IT
- ✅ **Nachteile**: Vendor Lock-in, Flexibilitätsgrenzen
- ✅ **Anwendungsfälle**: Business-Apps, Prototyping, Workflows
- ✅ **Plattformen**: OutSystems, Mendix, Power Apps, Bubble

### Checkliste für Entscheidung
- [ ] Anforderungen klar definiert
- [ ] Komplexität eingeschätzt
- [ ] Budget und Ressourcen geplant
- [ ] Vendor Lock-in geprüft
- [ ] Skalierbarkeit bedacht
- [ ] Sicherheitsanforderungen analysiert
- [ ] Team-Kompetenzen bewertet

---

## Nächste Schritte

Nachdem du diese Grundlagen beherrschst:
1. **Plattform auswählen** - Demo-Accounts testen
2. **Pilot-Projekt** - Kleine Anwendung bauen
3. **Training** - Team schulen
4. **Governance** - Standards definieren
5. **Skalierung** - Erweitern auf mehr Anwendungen

**Empfohlene Ressourcen:**
- [Gartner Magic Quadrant Low Code](https://www.gartner.com/)
- [Forrester Wave Low Code](https://www.forrester.com/)
- [Low Code Academy](https://www.lowcodeacademy.com/)
- [OutSystems Learning](https://www.outsystems.com/learning/)
