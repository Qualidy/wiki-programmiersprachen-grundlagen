# XML Grundlagen 4 – XQuery & Advanced XML

!!! abstract "Lernziele"
    Nach diesem Kapitel kannst du …

    - **XQuery** zur Abfrage von XML-Datenbanken verwenden.
    - **XSLT 2.0/3.0** erweiterte Features verstehen.
    - **XML-Validierung** mit Schematron durchführen.
    - **XML-Parsing** in verschiedenen Sprachen nutzen.
    - **XML-Sicherheit** und Best Practices anwenden.

---

## Einführung

**XQuery** ist eine Abfragesprache für XML-Datenbanken:
- **XPath-basiert**: Erweitert XPath um komplexe Abfragen
- **SQL-ähnlich**: SELECT, WHERE, ORDER BY, JOIN
- **Funktional**: Verarbeitung von XML-Dokumenten
- **Standardisiert**: W3C XQuery 1.0, 3.0, 3.1

**Advanced XML** umfasst:
- **XSLT 2.0/3.0**: Erweiterte Transformationen
- **Schematron**: Regelbasierte Validierung
- **XProc**: Pipeline-Verarbeitung
- **XForms**: XML-basierte Formulare

---

## XQuery

### Grundlagen
```xquery
(: XQuery-Beispiel :)
let $doc := doc("adressbuch.xml")
return $doc//kontakt[name="Max Mustermann"]
```

### Struktur
```xquery
(: XQuery-Modul :)
xquery version "3.1";

module namespace my = "http://example.com/my";

declare function my:summe($zahlen as xs:integer*) as xs:integer {
  sum($zahlen)
};
```

### XPath in XQuery
```xquery
(: Basis-Abfragen :)
let $doc := doc("adressbuch.xml")

(: Alle Kontakte :)
return $doc//kontakt

(: Mit Bedingung :)
return $doc//kontakt[alter > 25]

(: Mit Sortierung :)
return $doc//kontakt order by name ascending
```

### FLWOR-Ausdrücke
```xquery
(: For-Let-Where-Order-Return :)
for $kontakt in doc("adressbuch.xml")//kontakt
let $name := $kontakt/name
where $kontakt/alter > 25
order by $name ascending
return $name
```

### Beispiel: Komplexe Abfrage
```xquery
(: Alle Kontakte aus Berlin mit mehr als 100 Follower :)
let $doc := doc("adressbuch.xml")
for $k in $doc//kontakt
where $k/adresse/stadt = "Berlin"
  and $k/follower > 100
order by $k/name ascending
return
  <kontakt>
    {$k/name}
    {$k/email}
    {$k/follower}
  </kontakt>
```

### Funktionen in XQuery
```xquery
(: Eigene Funktionen :)
declare function local:formatiereName($name as xs:string) as xs:string {
  concat(upper-case(substring($name, 1, 1)), substring($name, 2))
};

(: Verwendung :)
for $k in doc("adressbuch.xml")//kontakt
return local:formatiereName($k/name)
```

### XQuery mit JSON
```xquery
(: XQuery 3.1 unterstützt JSON :)
let $data := json-doc("data.json")
return $data?users[?age > 25]
```

{{ task(file="tasks/03_00_05.yaml") }}

---

## XSLT 2.0/3.0 (Erweiterte Features)

### XSLT 2.0: Gruppierung
```xml
<!-- Gruppierung nach Stadt -->
<xsl:for-each-group select="kontakt" group-by="adresse/stadt">
  <stadt name="{current-grouping-key()}">
    <xsl:for-each select="current-group()">
      <kontakt>
        <name><xsl:value-of select="name"/></name>
      </kontakt>
    </xsl:for-each>
  </stadt>
</xsl:for-each-group>
```

### XSLT 2.0: Sequenzen
```xml
<!-- Sequenzen verarbeiten -->
<xsl:variable name="ergebnis" as="element()*">
  <xsl:for-each select="kontakt">
    <item>
      <name><xsl:value-of select="name"/></name>
    </item>
  </xsl:for-each>
</xsl:variable>
```

### XSLT 3.0: Funktionen
```xml
<!-- Eigene Funktionen in XSLT 3.0 -->
<xsl:function name="local:formatiereDatum" as="xs:string">
  <xsl:param name="datum" as="xs:date"/>
  <xsl:value-of select="format-date($datum, '[D].[M].[Y]')"/>
</xsl:function>
```

### XSLT 3.0: Map & Array
```xml
<!-- Map verwenden -->
<xsl:variable name="config" select="map {
  'api-key': 'abc123',
  'timeout': 5000
}"/>

<!-- Array verwenden -->
<xsl:variable name="items" select="[1, 2, 3, 4, 5]"/>
```

### XSLT 3.0: Streaming
```xml
<!-- Streaming für große Dateien -->
<xsl:mode streamable="yes"/>

<xsl:template match="kontakt">
  <!-- Verarbeitung ohne vollständiges Laden -->
  <xsl:value-of select="name"/>
</xsl:template>
```

---

## Schematron (Regelbasierte Validierung)

### Was ist Schematron?
- **Regelbasierte** Validierung (nur strukturbasiert)
- **XSLT-basiert**: Wird in XSLT transformiert
- **Flexibel**: Komplexe Business-Regeln
- **Kombinierbar**: Mit DTD/XSD

### Grundlegende Schematron-Datei
```xml
<?xml version="1.0" encoding="UTF-8"?>
<sch:schema xmlns:sch="http://purl.oclc.org/dsdl/schematron">
  <sch:title>Adressbuch-Validierung</sch:title>

  <!-- Regel: Jeder Kontakt muss eine Email haben -->
  <sch:rule context="kontakt">
    <sch:assert test="email"
                role="error">Jeder Kontakt muss eine Email haben</sch:assert>
  </sch:rule>

  <!-- Regel: Email muss gültig sein -->
  <sch:rule context="email">
    <sch:assert test="contains(., '@')"
                role="error">Ungültige Email-Adresse</sch:assert>
  </sch:rule>

  <!-- Regel: ID muss einzigartig sein -->
  <sch:rule context="kontakt">
    <sch:assert test="count(//kontakt[@id=current()/@id]) = 1"
                role="error">ID muss einzigartig sein</sch:assert>
  </sch:rule>

  <!-- Regel: Telefon muss mit +49 beginnen -->
  <sch:rule context="telefon">
    <sch:assert test="starts-with(., '+49')"
                role="warning">Telefonnummer sollte mit +49 beginnen</sch:assert>
  </sch:rule>
</sch:schema>
```

### Schematron mit XSLT
```bash
# Schematron in XSLT transformieren
xsltproc iso_svrl.xsl schematron.sch > schematron.xsl

# Validierung
xsltproc schematron.xsl adressbuch.xml > ergebnis.xml
```

### Schematron in Java
```java
import org.iso.schematron.*;

public class SchematronValidator {
    public static void main(String[] args) throws Exception {
        SchematronValidator validator =
            new SchematronValidator("schematron.sch");

        ValidationResult result = validator.validate("adressbuch.xml");

        if (result.isValid()) {
            System.out.println("Valid!");
        } else {
            for (String error : result.getErrors()) {
                System.out.println("Fehler: " + error);
            }
        }
    }
}
```

---

## XML-Parsing in verschiedenen Sprachen

### Java (DOM)
```java
import javax.xml.parsers.*;
import org.w3c.dom.*;

public class XMLParser {
    public static void main(String[] args) throws Exception {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        Document doc = factory.newDocumentBuilder()
            .parse(new File("adressbuch.xml"));

        NodeList contacts = doc.getElementsByTagName("kontakt");

        for (int i = 0; i < contacts.getLength(); i++) {
            Element contact = (Element) contacts.item(i);
            String name = contact.getElementsByTagName("name")
                .item(0).getTextContent();
            System.out.println("Name: " + name);
        }
    }
}
```

### Java (SAX - Event-basiert)
```java
import org.xml.sax.*;
import org.xml.sax.helpers.*;

public class SAXParser extends DefaultHandler {
    @Override
    public void startElement(String uri, String localName,
                            String qName, Attributes attributes) {
        if (qName.equals("kontakt")) {
            System.out.println("Neuer Kontakt:");
        }
    }

    @Override
    public void characters(char[] ch, int start, int length) {
        String text = new String(ch, start, length).trim();
        if (!text.isEmpty()) {
            System.out.println("Text: " + text);
        }
    }
}
```

### Python (ElementTree)
```python
import xml.etree.ElementTree as ET

# Laden
tree = ET.parse('adressbuch.xml')
root = tree.getroot()

# Durchlaufen
for kontakt in root.findall('kontakt'):
    name = kontakt.find('name').text
    email = kontakt.find('email').text
    print(f"{name}: {email}")

# Erstellen
neuer_kontakt = ET.Element('kontakt', id='4')
name = ET.SubElement(neuer_kontakt, 'name')
name.text = 'Neuer Kontakt'
tree.write('neu.xml')
```

### Python (lxml - Performance)
```python
from lxml import etree

# Laden mit XPath
tree = etree.parse('adressbuch.xml')
kontakte = tree.xpath('//kontakt[alter > 25]')

for k in kontakt:
    name = k.xpath('name/text()')[0]
    print(name)

# XSLT-Transformation
xslt = etree.parse('transform.xsl')
transform = etree.XSLT(xslt)
result = transform(tree)
print(result)
```

### JavaScript (Node.js)
```javascript
const { DOMParser } = require('xmldom');
const parser = new DOMParser();

const xml = `<adressbuch><kontakt><name>Max</name></kontakt></adressbuch>`;
const doc = parser.parseFromString(xml, 'text/xml');

const kontakte = doc.getElementsByTagName('kontakt');
for (let i = 0; i < kontakte.length; i++) {
  const name = kontakte[i].getElementsByTagName('name')[0].textContent;
  console.log(name);
}
```

---

## XML-Sicherheit

### 1. XXE (XML External Entity) Angriffe
**Problem**: Externe Entitäten können Dateien lesen
**Lösung**: Entitäten deaktivieren

```java
// Java: XXE-Schutz
DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();

// Deaktiviere externe Entitäten
factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
factory.setFeature("http://xml.org/sax/features/external-general-entities", false);
factory.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
factory.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);
```

### 2. XML-Bomben (Billion Laughs)
**Problem**: Rekursive Entitäten führen zu DoS
**Lösung**: Limits setzen

```java
// Limits setzen
factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, "");
factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, "");
```

### 3. XPath-Injection
**Problem**: Manipulation von XPath-Abfragen
**Lösung**: Parameterisierung

```java
// ❌ Schlecht (Injection möglich)
String xpath = "//kontakt[name='" + userInput + "']";

// ✅ Gut (Parameterisiert)
XPath xpath = XPathFactory.newInstance().newXPath();
XPathExpression expr = xpath.compile("//kontakt[name=$name]");
expr.setParameter("name", userInput);
```

### 4. Signierung & Verschlüsselung
```xml
<!-- XML-DSig (Signierung) -->
<SignedInfo>
  <CanonicalizationMethod Algorithm="..."/>
  <SignatureMethod Algorithm="..."/>
  <Reference URI="#kontakt1">
    <DigestMethod Algorithm="..."/>
    <DigestValue>abc123...</DigestValue>
  </Reference>
</SignedInfo>
<SignatureValue>xyz789...</SignatureValue>

<!-- XML-Enc (Verschlüsselung) -->
<EncryptedData Type="http://www.w3.org/2001/04/xmlenc#Element">
  <EncryptionMethod Algorithm="..."/>
  <CipherData>
    <CipherValue>verschlüsselte Daten</CipherValue>
  </CipherData>
</EncryptedData>
```

---

## Praktische Beispiele

### Beispiel 1: XQuery für API
```xquery
(: REST API mit XQuery :)
declare namespace output = "http://www.w3.org/2010/xslt-xquery-serialization";

declare option output:method "json";
declare option output:indent "yes";

let $users := doc("users.xml")//user
return
  map {
    "users": [
      for $u in $users
      return map {
        "id": $u/@id,
        "name": $u/name,
        "email": $u/email
      }
    ]
  }
```

### Beispiel 2: XSLT für PDF-Generierung
```xml
<xsl:stylesheet version="2.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:fo="http://www.w3.org/1999/XSL/Format">

  <xsl:template match="/">
    <fo:root>
      <fo:layout-master-set>
        <fo:simple-page-master master-name="A4"
                               page-height="29.7cm" page-width="21cm"
                               margin="2cm">
          <fo:region-body margin-top="2cm"/>
        </fo:simple-page-master>
      </fo:layout-master-set>

      <fo:page-sequence master-reference="A4">
        <fo:flow flow-name="xsl-region-body">
          <fo:block font-size="24pt" font-weight="bold">
            Adressbuch
          </fo:block>
          <xsl:apply-templates select="adressbuch/kontakt"/>
        </fo:flow>
      </fo:page-sequence>
    </fo:root>
  </xsl:template>

  <xsl:template match="kontakt">
    <fo:block space-after="10pt">
      <fo:inline font-weight="bold">
        <xsl:value-of select="name"/>
      </fo:inline>
      <fo:block font-size="12pt">
        Email: <xsl:value-of select="email"/>
      </fo:block>
    </fo:block>
  </xsl:template>
</xsl:stylesheet>
```

### Beispiel 3: Schematron für Business-Regeln
```xml
<?xml version="1.0" encoding="UTF-8"?>
<sch:schema xmlns:sch="http://purl.oclc.org/dsdl/schematron">
  <sch:title>Business Rules</sch:title>

  <!-- Regel: Mindestens 3 Kontakte pro Stadt -->
  <sch:rule context="adressbuch">
    <sch:let name="staedte" value="distinct-values(//adresse/stadt)"/>
    <sch:let name="minKontakte" value="3"/>

    <sch:assert test="count(//adresse/stadt[. = $staedte]) >= $minKontakte"
                role="error">Jede Stadt muss mindestens 3 Kontakte haben</sch:assert>
  </sch:rule>

  <!-- Regel: Keine Duplikate bei Email -->
  <sch:rule context="email">
    <sch:assert test="count(//email[. = current()]) = 1"
                role="error">Email muss einzigartig sein</sch:assert>
  </sch:rule>

  <!-- Regel: Telefonnummer muss gültig sein -->
  <sch:rule context="telefon">
    <sch:assert test="matches(., '^\+\d{1,3}\d{9,15}$')"
                role="error">Telefonnummer muss im Format +49123456789 sein</sch:assert>
  </sch:rule>
</sch:schema>
```

---

## Häufige Fehler & Best Practices

### Fehler 1: XXE-Angriffe
```xml
<!-- ❌ Gefährlich (XXE möglich) -->
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<root>&xxe;</root>

<!-- ✅ Sicher (Entitäten deaktiviert) -->
<root>Daten</root>
```

### Fehler 2: XPath-Injection
```java
// ❌ Schlecht (Injection möglich)
String xpath = "//user[name='" + name + "']";

// ✅ Gut (Parameterisiert)
XPath xpath = XPathFactory.newInstance().newXPath();
XPathExpression expr = xpath.compile("//user[name=$name]");
expr.setParameter("name", name);
```

### Fehler 3: Zu große XML-Dateien
```java
// ❌ Schlecht (DOM lädt alles in Speicher)
Document doc = builder.parse(largeFile);

// ✅ Gut (SAX oder StAX für große Dateien)
SAXParser saxParser = factory.newSAXParser();
saxParser.parse(largeFile, handler);
```

### Best Practices
1. **XXE-Schutz** immer aktivieren
2. **XPath-Parameterisierung** verwenden
3. **SAX/StAX** für große Dateien
4. **Schematron** für Business-Regeln
5. **XML-Signierung** für Sicherheit
6. **XQuery** für komplexe Abfragen
7. **XSLT 3.0** für moderne Transformationen

---

## Zusammenfassung & Checkliste

### Wichtige Konzepte
- ✅ **XQuery**: FLWOR, Funktionen, JSON-Unterstützung
- ✅ **XSLT 2.0/3.0**: Gruppierung, Sequenzen, Streaming
- ✅ **Schematron**: Regelbasierte Validierung
- ✅ **XML-Parsing**: DOM, SAX, StAX, lxml
- ✅ **Sicherheit**: XXE, XPath-Injection, Limits

### Checkliste für XML
- [ ] XXE-Schutz aktiviert
- [ ] XPath-Parameterisierung
- [ ] Schematron für Business-Regeln
- [ ] SAX/StAX für große Dateien
- [ ] XML-Signierung bei Bedarf
- [ ] XQuery für komplexe Abfragen

---

## Nächste Schritte

Nachdem du diese Grundlagen beherrschst:
1. **XProc** - XML-Pipeline-Verarbeitung
2. **XForms** - XML-basierte Formulare
3. **XSL-FO** - Druckausgaben
4. **XML-Datenbanken** - eXist-db, BaseX

**Empfohlene Ressourcen:**
- [W3Schools XQuery](https://www.w3schools.com/xml/xquery_intro.asp)
- [XSLT 3.0 Specification](https://www.w3.org/TR/xslt-30/)
- [Schematron](http://schematron.com/)
- [XML Security](https://www.w3.org/XML/Security/)
