# XML Grundlagen 3 – XPath & XSLT

!!! abstract "Lernziele"
    Nach diesem Kapitel kannst du …

    - **XPath** zur Abfrage von XML-Daten verwenden.
    - **XSLT** zur Transformation von XML in andere Formate.
    - **XSL-FO** für PDF-Generierung verstehen.
    - **Praktische Anwendungen** von XPath und XSLT umsetzen.

---

## Einführung

**XPath** und **XSLT** sind mächtige Werkzeuge für die Arbeit mit XML:
- **XPath**: Abfragesprache für XML-Dokumente (ähnlich SQL für Datenbanken)
- **XSLT**: Transformationssprache (XML → HTML, PDF, Text, etc.)
- **XSL-FO**: Formatierungsobjekte für Druckausgaben

**Wichtige Fakten:**
- XPath ist Teil von XSLT, aber auch unabhängig nutzbar
- XSLT ist eine **funktionale Programmiersprache**
- Beide sind **W3C-Standards**
- Werden in vielen Enterprise-Anwendungen eingesetzt

---

## XPath

### Was ist XPath?
XPath ist eine **Abfragesprache** für XML-Dokumente. Mit XPath kannst du:
- **Elemente** auswählen
- **Attribute** abfragen
- **Bedingungen** anwenden
- **Knoten** navigieren

### XPath-Syntax

#### 1. Pfad-Ausdrücke
```xpath
/                  # Wurzelelement
//                 # Alle Elemente im Dokument
.                  # Aktuelles Element
..                 # Eltern-Element
@                  # Attribut-Referenz
```

#### 2. Beispiele
```xpath
/adressbuch/kontakt          # Alle Kontakt-Elemente unter adressbuch
//kontakt                    # Alle Kontakt-Elemente im Dokument
//kontakt[@id='1']           # Kontakt mit id='1'
//kontakt/name               # Alle Namen aller Kontakte
/adressbuch/kontakt[1]       # Erster Kontakt (1-based)
/adressbuch/kontakt[last()]  # Letzter Kontakt
//kontakt[status='aktiv']    # Alle aktiven Kontakte
```

#### 3. Axes (Achsen)
```xpath
child::          # Kinder (Standard)
parent::         # Eltern
ancestor::       # Alle Vorfahren
descendant::     # Alle Nachfahren
following::      # Nachfolgende Elemente
preceding::      # Vorherige Elemente
attribute::      # Attribute (kurz: @)
```

#### 4. Bedingungen & Operatoren
```xpath
//kontakt[alter > 25]           # Kontakte älter als 25
//kontakt[not(status)]           # Kontakte ohne Status
//kontakt[contains(name, 'Max')] # Name enthält 'Max'
//kontakt[starts-with(email, 'max')] # Email beginnt mit 'max'
//kontakt[not(telefon)]          # Kontakte ohne Telefon
```

#### 5. Funktionen
```xpath
# String-Funktionen
string-length(name)          # Länge des Namens
concat(name, ' ', email)     # Verkettung
substring(name, 1, 3)        # Teilstring
upper-case(name)             # Großbuchstaben
lower-case(name)             # Kleinbuchstaben

# Numerische Funktionen
count(//kontakt)             # Anzahl Kontakte
sum(//alter)                 # Summe aller Alter
avg(//alter)                 # Durchschnittsalter
min(//alter)                 # Minimales Alter
max(//alter)                 # Maximales Alter

# Logische Funktionen
not(condition)               # Negation
true() / false()             # Wahr/Falsch
```

### Praktische Beispiele

#### Beispiel 1: Adressbuch-Abfragen
```xpath
# Alle Kontakte mit Email
//kontakt[email]

# Kontakte aus Berlin
//kontakt[stadt='Berlin']

# Kontakte mit mehr als 100 Follower
//kontakt[follower > 100]

# Erster Kontakt pro Stadt
//stadt/preceding-sibling::kontakt[1]

# Kontakte ohne Telefon
//kontakt[not(telefon)]
```

#### Beispiel 2: Komplexe Abfragen
```xpath
# Kontakte, die älter als 25 sind und aus Berlin kommen
//kontakt[alter > 25 and stadt='Berlin']

# Kontakte mit bestimmten Domains
//kontakt[contains(email, '@gmail.com') or contains(email, '@yahoo.com')]

# Sortierung (XPath 2.0+)
//kontakt order by alter descending

# Aggregation
//stadt[//kontakt[@stadt=current()]/count() > 5]
```

{{ task(file="tasks/03_00_04.yaml") }}

---

## XSLT (XML Stylesheet Language Transformations)

### Was ist XSLT?
XSLT ist eine **Transformationssprache**, die XML in andere Formate umwandelt:
- **XML → HTML** für Webseiten
- **XML → PDF** für Dokumente
- **XML → Text** für Exporte
- **XML → XML** für Strukturänderungen

### XSLT-Struktur
```xml
<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

  <!-- Output-Format -->
  <xsl:output method="html" indent="yes"/>

  <!-- Template für Wurzelelement -->
  <xsl:template match="/">
    <html>
      <body>
        <xsl:apply-templates/>
      </body>
    </html>
  </xsl:template>

  <!-- Template für Kontakte -->
  <xsl:template match="kontakt">
    <div class="kontakt">
      <h2><xsl:value-of select="name"/></h2>
      <p>Email: <xsl:value-of select="email"/></p>
    </div>
  </xsl:template>

</xsl:stylesheet>
```

### XSLT-Elemente

#### 1. `<xsl:template>`
```xml
<!-- Match-Attribut: Welche Elemente werden transformiert -->
<xsl:template match="kontakt">
  <!-- Transformation -->
</xsl:template>

<!-- Match mit Pfad -->
<xsl:template match="/adressbuch/kontakt">
  <!-- Nur direkte Kinder von adressbuch -->
</xsl:template>

<!-- Match mit Bedingung -->
<xsl:template match="kontakt[status='aktiv']">
  <!-- Nur aktive Kontakte -->
</xsl:template>
```

#### 2. `<xsl:value-of>`
```xml
<!-- Wert eines Elements oder Attributs ausgeben -->
<xsl:value-of select="name"/>
<xsl:value-of select="@id"/>

<!-- Mit Formatierung -->
<xsl:value-of select="format-number(preis, '#.##0,00')"/>
```

#### 3. `<xsl:for-each>`
```xml
<!-- Schleife über Elemente -->
<xsl:for-each select="kontakt">
  <div>
    <xsl:value-of select="name"/>
  </div>
</xsl:for-each>

<!-- Mit Sortierung -->
<xsl:for-each select="kontakt">
  <xsl:sort select="name" order="ascending"/>
  <!-- ... -->
</xsl:for-each>
```

#### 4. `<xsl:if>` und `<xsl:choose>`
```xml
<!-- Bedingte Ausgabe -->
<xsl:if test="alter > 25">
  <span class="adult">Erwachsen</span>
</xsl:if>

<!-- Mehrere Bedingungen -->
<xsl:choose>
  <xsl:when test="status='aktiv'">
    <span class="aktiv">Aktiv</span>
  </xsl:when>
  <xsl:when test="status='inaktiv'">
    <span class="inaktiv">Inaktiv</span>
  </xsl:when>
  <xsl:otherwise>
    <span class="unbekannt">Unbekannt</span>
  </xsl:otherwise>
</xsl:choose>
```

#### 5. `<xsl:apply-templates>`
```xml
<!-- Weitergabe an andere Templates -->
<xsl:template match="adressbuch">
  <html>
    <body>
      <xsl:apply-templates select="kontakt"/>
    </body>
  </html>
</xsl:template>

<xsl:template match="kontakt">
  <!-- Verarbeitung jedes Kontakts -->
</xsl:template>
```

### Praktische Beispiele

#### Beispiel 1: XML → HTML
**XML:**
```xml
<adressbuch>
  <kontakt id="1">
    <name>Max Mustermann</name>
    <email>max@example.com</email>
    <telefon>+49 123 456789</telefon>
  </kontakt>
</adressbuch>
```

**XSLT:**
```xml
<xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:output method="html" indent="yes"/>

  <xsl:template match="/">
    <html>
      <head>
        <title>Adressbuch</title>
        <style>
          .kontakt { border: 1px solid #ccc; margin: 10px; padding: 10px; }
          .name { font-weight: bold; }
        </style>
      </head>
      <body>
        <h1>Adressbuch</h1>
        <xsl:apply-templates select="adressbuch/kontakt"/>
      </body>
    </html>
  </xsl:template>

  <xsl:template match="kontakt">
    <div class="kontakt">
      <p class="name"><xsl:value-of select="name"/></p>
      <p>Email: <xsl:value-of select="email"/></p>
      <xsl:if test="telefon">
        <p>Telefon: <xsl:value-of select="telefon"/></p>
      </xsl:if>
    </div>
  </xsl:template>
</xsl:stylesheet>
```

#### Beispiel 2: XML → PDF (XSL-FO)
```xml
<xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:fo="http://www.w3.org/1999/XSL/Format">
  <xsl:output method="xml" indent="yes"/>

  <xsl:template match="/">
    <fo:root>
      <fo:layout-master-set>
        <fo:simple-page-master master-name="A4"
                               page-height="29.7cm" page-width="21cm"
                               margin="2cm">
          <fo:region-body margin-top="2cm"/>
        </fo:simple-page-master>
      </fo:layout-master-set>

      <fo:page-sequence master-reference="A4">
        <fo:flow flow-name="xsl-region-body">
          <fo:block font-size="24pt" font-weight="bold">
            Adressbuch
          </fo:block>
          <xsl:apply-templates select="adressbuch/kontakt"/>
        </fo:flow>
      </fo:page-sequence>
    </fo:root>
  </xsl:template>

  <xsl:template match="kontakt">
    <fo:block font-size="14pt" space-after="10pt">
      <fo:inline font-weight="bold">
        <xsl:value-of select="name"/>
      </fo:inline>
      <fo:block font-size="12pt">
        Email: <xsl:value-of select="email"/>
      </fo:block>
    </fo:block>
  </xsl:template>
</xsl:stylesheet>
```

#### Beispiel 3: XML → CSV
```xml
<xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:output method="text" encoding="UTF-8"/>

  <xsl:template match="/">
    <xsl:text>ID,Name,Email,Telefon&#10;</xsl:text>
    <xsl:apply-templates select="adressbuch/kontakt"/>
  </xsl:template>

  <xsl:template match="kontakt">
    <xsl:value-of select="@id"/>
    <xsl:text>,</xsl:text>
    <xsl:value-of select="name"/>
    <xsl:text>,</xsl:text>
    <xsl:value-of select="email"/>
    <xsl:text>,</xsl:text>
    <xsl:value-of select="telefon"/>
    <xsl:text>&#10;</xsl:text>
  </xsl:template>
</xsl:stylesheet>
```

---

## Praktische Anwendungen

### 1. Web-Service Response Transformation
```xml
<!-- XSLT für REST API Response -->
<xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:output method="json" indent="yes"/>

  <xsl:template match="/">
    {
      "users": [
        <xsl:for-each select="users/user">
          {
            "id": "<xsl:value-of select="@id"/>",
            "name": "<xsl:value-of select="name"/>",
            "email": "<xsl:value-of select="email"/>"
          }<xsl:if test="position() != last()">,</xsl:if>
        </xsl:for-each>
      ]
    }
  </xsl:template>
</xsl:stylesheet>
```

### 2. XML-Migration
```xml
<!-- Altes Format → Neues Format -->
<xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:template match="/">
    <neues-adressbuch>
      <xsl:apply-templates select="altes-adressbuch/person"/>
    </neues-adressbuch>
  </xsl:template>

  <xsl:template match="person">
    <kontakt id="{@nummer}">
      <name><xsl:value-of select="vorname"/> <xsl:value-of select="nachname"/></name>
      <email><xsl:value-of select="mail"/></email>
    </kontakt>
  </xsl:template>
</xsl:stylesheet>
```

### 3. Dynamische HTML-Generierung
```xml
<!-- Generiert HTML mit JavaScript -->
<xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:template match="/">
    <html>
      <body>
        <script>
          var data = [
            <xsl:for-each select="daten/item">
              {
                id: "<xsl:value-of select="@id"/>",
                name: "<xsl:value-of select="name"/>"
              }<xsl:if test="position() != last()">,</xsl:if>
            </xsl:for-each>
          ];
          // Verarbeite data...
        </script>
      </body>
    </html>
  </xsl:template>
</xsl:stylesheet>
```

---

## Java-Integration

### XPath in Java
```java
import javax.xml.xpath.*;
import org.w3c.dom.*;

public class XPathBeispiel {
    public static void main(String[] args) throws Exception {
        // Dokument laden
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        Document doc = factory.newDocumentBuilder()
            .parse(new File("adressbuch.xml"));

        // XPath erstellen
        XPathFactory xPathFactory = XPathFactory.newInstance();
        XPath xpath = xPathFactory.newXPath();

        // Abfrage ausführen
        String expression = "//kontakt[status='aktiv']/name";
        NodeList nodes = (NodeList) xpath.evaluate(
            expression, doc, XPathConstants.NODESET);

        // Ergebnisse ausgeben
        for (int i = 0; i < nodes.getLength(); i++) {
            System.out.println(nodes.item(i).getTextContent());
        }
    }
}
```

### XSLT in Java
```java
import javax.xml.transform.*;
import javax.xml.transform.stream.*;

public class XSLTBeispiel {
    public static void main(String[] args) throws Exception {
        // Transformer erstellen
        TransformerFactory factory = TransformerFactory.newInstance();
        Transformer transformer = factory.newTransformer(
            new StreamSource(new File("transform.xsl")));

        // Transformation ausführen
        transformer.transform(
            new StreamSource(new File("input.xml")),
            new StreamResult(new File("output.html")));
    }
}
```

---

## Häufige Fehler & Best Practices

### Fehler 1: XPath-Syntax-Fehler
```xpath
// ❌ Falsch (fehlende Klammern)
//kontakt[alter > 25 and status='aktiv'

// ✅ Gut
//kontakt[alter > 25 and status='aktiv']
```

### Fehler 2: XSLT-Template-Konflikte
```xml
<!-- ❌ Falsch (mehrere Templates matchen) -->
<xsl:template match="kontakt">
  <!-- ... -->
</xsl:template>

<xsl:template match="kontakt[@id='1']">
  <!-- ... -->
</xsl:template>

<!-- ✅ Gut (spezifischer zuerst) -->
<xsl:template match="kontakt[@id='1']">
  <!-- ... -->
</xsl:template>

<xsl:template match="kontakt">
  <!-- ... -->
</xsl:template>
```

### Fehler 3: Fehlende Namespace-Deklaration
```xml
<!-- ❌ Falsch (XSLT-Namespace fehlt) -->
<stylesheet version="1.0">
  <!-- ... -->
</stylesheet>

<!-- ✅ Gut -->
<xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <!-- ... -->
</xsl:stylesheet>
```

### Best Practices
1. **XPath 2.0+** für komplexere Abfragen
2. **Template-Regeln** statt großer Templates
3. **xsl:apply-templates** für bessere Wartbarkeit
4. **xsl:key** für performante Lookups
5. **xsl:variable** für wiederverwendbare Werte
6. **xsl:include/xsl:import** für Modularität

---

## Zusammenfassung & Checkliste

### Wichtige Konzepte
- ✅ **XPath**: Abfragesprache für XML-Daten
- ✅ **XSLT**: Transformationssprache (XML → andere Formate)
- ✅ **XSL-FO**: Formatierungsobjekte für PDF/Druck
- ✅ **Axes**: Navigation im XML-Baum
- ✅ **Funktionen**: String, Zahl, Logik
- ✅ **Templates**: Regelbasierte Transformation

### Checkliste für XPath/XSLT
- [ ] XPath-Syntax korrekt
- [ ] Axes korrekt verwendet
- [ ] Bedingungen logisch
- [ ] XSLT-Namespaces deklariert
- [ ] Templates korrekt gematcht
- [ ] Output-Format korrekt

---

## Nächste Schritte

Nachdem du diese Grundlagen beherrschst:
1. **XQuery** - Abfragesprache für XML-Datenbanken
2. **XSLT 2.0/3.0** - Erweiterte Features
3. **Schematron** - XML-Validierung mit Regeln
4. **XProc** - Pipeline-Verarbeitung

**Empfohlene Ressourcen:**
- [MDN Web Docs - XPath](https://developer.mozilla.org/de/docs/Web/API/XPath)
- [W3Schools XSLT Tutorial](https://www.w3schools.com/xml/xsl_intro.asp)
- [XSLT.com](https://www.xslt.com/)
