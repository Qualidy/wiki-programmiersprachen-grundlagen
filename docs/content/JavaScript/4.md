# JavaScript Grundlagen 4 – Async Programming & APIs

!!! abstract "Lernziele"
    Nach diesem Kapitel kannst du …

    - **Asynchrone Programmierung** verstehen und anwenden.
    - **Promises** und **Async/Await** nutzen.
    - **Fetch API** für HTTP-Anfragen verwenden.
    - **Fehlerbehandlung** in asynchronem Code.
    - **Async-Architektur** für Webanwendungen planen.

---

## Einführung

**Asynchrone Programmierung** ist essenziell für moderne Webanwendungen. Sie ermöglicht:
- **Daten von Servern** laden ohne Seite zu blockieren
- **Benutzerinteraktion** während Ladevorgängen
- **Parallele Verarbeitung** von Aufgaben
- **Responsive UI** auch bei langsamen Netzwerken

**Wichtige Fakten:**
- JavaScript ist **single-threaded** (ein Thread)
- **Event Loop** ermöglicht Asynchronität
- **Promises** (ES6) lösen Callback-Hell
- **Async/Await** (ES8) macht Code lesbarer

---

## Callbacks (Grundlage)

### Was ist ein Callback?
Eine Funktion, die als Parameter an eine andere Funktion übergeben wird.

```javascript
// Synchroner Callback
function verarbeiteDaten(daten, callback) {
  const ergebnis = daten.map(x => x * 2);
  callback(ergebnis);
}

verarbeiteDaten([1, 2, 3], (result) => {
  console.log(result); // [2, 4, 6]
});
```

### Asynchrone Callbacks
```javascript
// Simuliere asynchrone Operation
function ladeDaten(callback) {
  setTimeout(() => {
    const daten = { name: "Max", alter: 25 };
    callback(daten);
  }, 1000); // 1 Sekunde Verzögerung
}

ladeDaten((daten) => {
  console.log("Daten geladen:", daten);
});

console.log("Dies wird sofort ausgeführt");
```

### Callback-Hell (Problem)
```javascript
// ❌ Schlecht: Verschachtelte Callbacks
ladeDaten((daten1) => {
  verarbeiteDaten(daten1, (ergebnis1) => {
    ladeWeitereDaten(ergebnis1, (daten2) => {
      verarbeiteWeitereDaten(daten2, (ergebnis2) => {
        console.log("Fertig:", ergebnis2);
      });
    });
  });
});
```

---

## Promises (ES6)

### Was ist ein Promise?
Ein **Promise** ist ein Objekt, das den **Zustand** einer asynchronen Operation repräsentiert:
- **Pending**: Operation läuft
- **Fulfilled**: Erfolgreich abgeschlossen
- **Rejected**: Fehler aufgetreten

```javascript
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    const erfolg = Math.random() > 0.5;
    if (erfolg) {
      resolve("Erfolg!");
    } else {
      reject("Fehler!");
    }
  }, 1000);
});
```

### Promise-Verarbeitung
```javascript
promise
  .then((ergebnis) => {
    console.log("Erfolg:", ergebnis);
  })
  .catch((fehler) => {
    console.log("Fehler:", fehler);
  })
  .finally(() => {
    console.log("Immer ausgeführt");
  });
```

### Promise-Ketten
```javascript
function ladeDaten() {
  return new Promise((resolve) => {
    setTimeout(() => resolve({ id: 1, name: "Max" }), 500);
  });
}

function verarbeiteDaten(daten) {
  return new Promise((resolve) => {
    setTimeout(() => resolve({ ...daten, verarbeitet: true }), 500);
  });
}

ladeDaten()
  .then(daten => verarbeiteDaten(daten))
  .then(ergebnis => {
    console.log("Fertig:", ergebnis);
    return ergebnis.id;
  })
  .then(id => console.log("ID:", id))
  .catch(fehler => console.log("Fehler:", fehler));
```

### Promise.all (Parallele Ausführung)
```javascript
const p1 = fetch('https://api.example.com/users');
const p2 = fetch('https://api.example.com/posts');
const p3 = fetch('https://api.example.com/comments');

Promise.all([p1, p2, p3])
  .then(responses => {
    console.log("Alle Anfragen abgeschlossen");
    return Promise.all(responses.map(r => r.json()));
  })
  .then(data => {
    console.log("Alle Daten:", data);
  })
  .catch(fehler => {
    console.log("Mindestens eine Anfrage fehlgeschlagen:", fehler);
  });
```

### Promise.race (Erster gewinnt)
```javascript
const timeout = new Promise((resolve, reject) => {
  setTimeout(() => reject("Timeout!"), 5000);
});

const fetchPromise = fetch('https://api.example.com/data');

Promise.race([fetchPromise, timeout])
  .then(ergebnis => console.log("Ergebnis:", ergebnis))
  .catch(fehler => console.log("Fehler:", fehler));
```

{{ task(file="tasks/02_00_10.yaml") }}

---

## Async/Await (ES8)

### Syntax
```javascript
// Async Function
async function ladeDatenAsync() {
  try {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log(data);
    return data;
  } catch (fehler) {
    console.log("Fehler:", fehler);
    throw fehler;
  }
}

// Aufruf
ladeDatenAsync()
  .then(data => console.log("Erfolg:", data))
  .catch(fehler => console.log("Fehler:", fehler));
```

### Vorteile von Async/Await
```javascript
// ❌ Mit Promises (Callback-Hell)
function komplexeOperation() {
  return ladeDaten()
    .then(daten1 => verarbeiteDaten(daten1))
    .then(daten2 => ladeWeitereDaten(daten2))
    .then(daten3 => verarbeiteWeitereDaten(daten3));
}

// ✅ Mit Async/Await (lesbarer)
async function komplexeOperation() {
  const daten1 = await ladeDaten();
  const daten2 = await verarbeiteDaten(daten1);
  const daten3 = await ladeWeitereDaten(daten2);
  return await verarbeiteWeitereDaten(daten3);
}
```

### Parallel vs. Seriell
```javascript
// Seriell (nacheinander)
async function seriell() {
  const users = await fetch('/api/users').then(r => r.json());
  const posts = await fetch('/api/posts').then(r => r.json());
  return { users, posts };
}

// Parallel (gleichzeitig)
async function parallel() {
  const [users, posts] = await Promise.all([
    fetch('/api/users').then(r => r.json()),
    fetch('/api/posts').then(r => r.json())
  ]);
  return { users, posts };
}
```

### Error Handling
```javascript
async function mitFehlerbehandlung() {
  try {
    const response = await fetch('https://api.example.com/data');

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }

    const data = await response.json();
    return data;

  } catch (fehler) {
    console.error("Fehler beim Laden:", fehler.message);

    // Fallback-Daten
    return { error: true, data: [] };
  } finally {
    console.log("Aufräumen...");
  }
}
```

---

## Fetch API

### Grundlegende Anfrage
```javascript
// GET-Anfrage
async function ladeBenutzer() {
  try {
    const response = await fetch('https://api.example.com/users/1');

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }

    const user = await response.json();
    console.log(user);
    return user;
  } catch (fehler) {
    console.log("Fehler:", fehler);
  }
}
```

### POST-Anfrage
```javascript
async function erstelleBenutzer(benutzer) {
  const response = await fetch('https://api.example.com/users', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(benutzer)
  });

  if (!response.ok) {
    throw new Error(`HTTP ${response.status}`);
  }

  return await response.json();
}

// Verwendung
erstelleBenutzer({ name: "Anna", email: "anna@example.com" })
  .then(neuerBenutzer => console.log("Erstellt:", neuerBenutzer));
```

### Optionen
```javascript
const options = {
  method: 'PUT', // GET, POST, PUT, DELETE, PATCH
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer token123'
  },
  body: JSON.stringify({ data: 'value' }),
  mode: 'cors', // cors, no-cors, same-origin
  cache: 'no-cache', // default, no-store, reload
  credentials: 'include', // include, same-origin, omit
  redirect: 'follow', // follow, manual, error
  referrer: 'client',
  integrity: 'sha256-...'
};

fetch('https://api.example.com/data', options);
```

### Timeout mit AbortController
```javascript
const controller = new AbortController();
const signal = controller.signal;

// Timeout nach 5 Sekunden
const timeout = setTimeout(() => controller.abort(), 5000);

try {
  const response = await fetch('https://api.example.com/data', { signal });
  const data = await response.json();
  clearTimeout(timeout);
  console.log(data);
} catch (fehler) {
  if (fehler.name === 'AbortError') {
    console.log("Anfrage abgebrochen (Timeout)");
  } else {
    console.log("Fehler:", fehler);
  }
}
```

{{ task(file="tasks/02_00_11.yaml") }}

---

## Praktische Beispiele

### Beispiel 1: GitHub API
```javascript
async function ladeGitHubUser(username) {
  try {
    const response = await fetch(`https://api.github.com/users/${username}`);

    if (!response.ok) {
      if (response.status === 404) {
        throw new Error("Benutzer nicht gefunden");
      }
      throw new Error(`HTTP ${response.status}`);
    }

    const user = await response.json();

    return {
      name: user.name || user.login,
      followers: user.followers,
      publicRepos: user.public_repos,
      avatar: user.avatar_url
    };

  } catch (fehler) {
    console.error("GitHub API Fehler:", fehler.message);
    return null;
  }
}

// Verwendung
ladeGitHubUser("octocat")
  .then(user => {
    if (user) {
      console.log(`${user.name} hat ${user.followers} Follower`);
    }
  });
```

### Beispiel 2: Formular mit API
```javascript
const form = document.querySelector('#contact-form');
const statusDiv = document.querySelector('#status');

form.addEventListener('submit', async (event) => {
  event.preventDefault();

  const formData = new FormData(form);
  const data = Object.fromEntries(formData);

  statusDiv.textContent = 'Sende...';
  statusDiv.style.color = 'blue';

  try {
    const response = await fetch('/api/contact', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });

    if (!response.ok) {
      throw new Error(`Server error: ${response.status}`);
    }

    const result = await response.json();
    statusDiv.textContent = 'Nachricht gesendet!';
    statusDiv.style.color = 'green';
    form.reset();

  } catch (fehler) {
    statusDiv.textContent = `Fehler: ${fehler.message}`;
    statusDiv.style.color = 'red';
  }
});
```

### Beispiel 3: Parallel Data Loading
```javascript
async function ladeDashboardDaten() {
  try {
    const [users, posts, comments] = await Promise.all([
      fetch('/api/users').then(r => r.json()),
      fetch('/api/posts').then(r => r.json()),
      fetch('/api/comments').then(r => r.json())
    ]);

    // Verarbeite Daten
    const dashboard = {
      users: users.length,
      posts: posts.length,
      comments: comments.length,
      latestPost: posts[0]
    };

    return dashboard;

  } catch (fehler) {
    console.error("Dashboard Fehler:", fehler);
    throw fehler;
  }
}

// Verwendung mit UI-Update
async function renderDashboard() {
  const dashboard = await ladeDashboardDaten();

  document.querySelector('#user-count').textContent = dashboard.users;
  document.querySelector('#post-count').textContent = dashboard.posts;
  document.querySelector('#comment-count').textContent = dashboard.comments;
}
```

---

## Häufige Fehler & Best Practices

### Fehler 1: Async ohne await
```javascript
// ❌ Falsch (Promise wird nicht aufgelöst)
async function getData() {
  fetch('/api/data'); // Promise wird ignoriert!
}

// ✅ Gut
async function getData() {
  const response = await fetch('/api/data');
  return await response.json();
}
```

### Fehler 2: Fehlende Fehlerbehandlung
```javascript
// ❌ Falsch (unbehandelte Fehler)
async function getData() {
  const response = await fetch('/api/data');
  return await response.json();
}

// ✅ Gut
async function getData() {
  try {
    const response = await fetch('/api/data');
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    return await response.json();
  } catch (fehler) {
    console.error("Fehler:", fehler);
    return null;
  }
}
```

### Fehler 3: Race Conditions
```javascript
// ❌ Falsch (nicht abgesichert)
let data = null;
fetchData().then(d => data = d);
console.log(data); // null (noch nicht geladen)

// ✅ Gut (mit async/await)
async function loadData() {
  const data = await fetchData();
  console.log(data); // Daten sind verfügbar
}
```

### Best Practices
1. **Immer try/catch** bei async/await
2. **Response-Status prüfen** (response.ok)
3. **Timeout implementieren** für Netzwerk-Anfragen
4. **Loading-States** im UI anzeigen
5. **Cache-Strategien** für wiederholte Anfragen
6. **AbortController** für abbrechbare Anfragen

---

## Zusammenfassung & Checkliste

### Wichtige Konzepte
- ✅ **Callbacks**: Funktionen als Parameter
- ✅ **Promises**: Zustands-Objekte für asynchrone Operationen
- ✅ **Async/Await**: Syntactic Sugar für Promises
- ✅ **Fetch API**: Standard für HTTP-Anfragen
- ✅ **Error Handling**: try/catch für asynchrone Fehler
- ✅ **Parallelität**: Promise.all für gleichzeitige Anfragen

### Checkliste für Code
- [ ] Async/await statt Callback-Hell
- [ ] Try/catch für Fehlerbehandlung
- [ ] Response-Status prüfen (response.ok)
- [ ] Timeout implementieren
- [ ] Loading-States im UI
- [ ] AbortController für abbrechbare Anfragen
- [ ] JSON.parse/JSON.stringify korrekt verwenden

---

## Nächste Schritte

Nachdem du diese Grundlagen beherrschst:
1. **LocalStorage & SessionStorage** - Daten im Browser speichern
2. **ES6 Modules** - Code modularisieren
3. **Web Components** - Custom HTML-Elemente
4. **WebSockets** - Echtzeit-Kommunikation

**Empfohlene Ressourcen:**
- [MDN Web Docs - Fetch API](https://developer.mozilla.org/de/docs/Web/API/Fetch_API)
- [MDN Web Docs - Promises](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Promise)
- [JavaScript.info - Async/Await](https://javascript.info/async-await)
- [freeCodeCamp - JavaScript Async](https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/)
