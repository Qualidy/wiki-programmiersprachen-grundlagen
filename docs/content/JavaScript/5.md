# JavaScript Grundlagen 5 – Arrays & Objects

!!! abstract "Lernziele"
    Nach diesem Kapitel kannst du …

    - **Arrays** erstellen, manipulieren und durchlaufen.
    - **Objekte** (Key-Value Paare) verwenden und verändern.
    - **Destructuring** und **Spread Operator** anwenden.
    - **JSON** für Daten austausch nutzen.
    - **Map und Set** als moderne Datenstrukturen verstehen.

---

## Einführung

**Arrays** und **Objekte** sind die wichtigsten Datenstrukturen in JavaScript:
- **Arrays**: Geordnete Listen von Werten
- **Objekte**: Sammlung von Key-Value Paaren
- **JSON**: Standard für Datenaustausch
- **Map/Set**: Moderne, leistungsfähige Alternativen

---

## Arrays

### Erstellen
```javascript
// Leeres Array
const leeresArray = [];

// Mit Werten
const zahlen = [1, 2, 3, 4, 5];
const farben = ["Rot", "Grün", "Blau"];
const gemischt = [1, "Hallo", true, null];

// Array.from (aus Iterable)
const ausString = Array.from("Hallo"); // ["H", "a", "l", "l", "o"]

// Array.of
const neu = Array.of(1, 2, 3); // [1, 2, 3]
```

### Zugriff
```javascript
const farben = ["Rot", "Grün", "Blau"];

// Index (0-basiert)
console.log(farben[0]); // "Rot"
console.log(farben[1]); // "Grün"

// Ändern
farben[2] = "Gelb";
console.log(farben); // ["Rot", "Grün", "Gelb"]

// Länge
console.log(farben.length); // 3
```

### Methoden (Lesen)
```javascript
const zahlen = [1, 2, 3, 4, 5];

// Erstes/Letztes Element
console.log(zahlen[0]); // 1
console.log(zahlen[zahlen.length - 1]); // 5

// Includes (Prüfen)
console.log(zahlen.includes(3)); // true
console.log(zahlen.includes(10)); // false

// Find (Bedingung)
const gerade = zahlen.find(x => x % 2 === 0); // 2
const gross = zahlen.find(x => x > 10); // undefined

// FindIndex
const index = zahlen.findIndex(x => x === 3); // 2
```

### Methoden (Schreiben)
```javascript
const zahlen = [1, 2, 3];

// Hinzufügen
zahlen.push(4); // Am Ende: [1, 2, 3, 4]
zahlen.unshift(0); // Am Anfang: [0, 1, 2, 3, 4]

// Entfernen
zahlen.pop(); // Letztes: [0, 1, 2, 3]
zahlen.shift(); // Erstes: [1, 2, 3]

// Einfügen/Entfernen an Position
zahlen.splice(1, 0, 99); // Bei Index 1 einfügen: [1, 99, 2, 3]
zahlen.splice(1, 1); // Bei Index 1 löschen: [1, 2, 3]

// Kopieren
const kopie = zahlen.slice(); // [1, 2, 3]
const teil = zahlen.slice(1, 3); // [2, 3]
```

### Iteration
```javascript
const farben = ["Rot", "Grün", "Blau"];

// For-Schleife
for (let i = 0; i < farben.length; i++) {
  console.log(farben[i]);
}

// For-Each
farben.forEach((farbe, index) => {
  console.log(`${index}: ${farbe}`);
});

// For-Of
for (const farbe of farben) {
  console.log(farbe);
}

// Map (Transformation)
const gross = farben.map(f => f.toUpperCase());
console.log(gross); // ["ROT", "GRÜN", "BLAU"]

// Filter
const mitR = farben.filter(f => f.startsWith("R"));
console.log(mitR); // ["Rot"]

// Reduce
const summe = [1, 2, 3, 4].reduce((acc, curr) => acc + curr, 0);
console.log(summe); // 10
```

### Spread Operator (ES6)
```javascript
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

// Kombinieren
const kombiniert = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6]

// Kopieren
const kopie = [...arr1]; // [1, 2, 3]

// Mit anderen Werten
const mitNeu = [...arr1, 7, 8]; // [1, 2, 3, 7, 8]
```

{{ task(file="tasks/02_00_12.yaml") }}

---

## Objekte

### Erstellen
```javascript
// Literal-Syntax (empfohlen)
const person = {
  name: "Max",
  alter: 25,
  istAktiv: true
};

// Konstruktor (veraltet)
const person2 = new Object();
person2.name = "Anna";
person2.alter = 30;

// Object.create
const prototype = { gruss: "Hallo" };
const obj = Object.create(prototype);
obj.name = "Tom";
```

### Zugriff
```javascript
const person = { name: "Max", alter: 25 };

// Dot-Notation
console.log(person.name); // "Max"
console.log(person.alter); // 25

// Bracket-Notation (für dynamische Keys)
const key = "name";
console.log(person[key]); // "Max"

// Ändern
person.alter = 26;
person["stadt"] = "Berlin"; // Neues Property

// Löschen
delete person.istAktiv;
```

### Verschachtelte Objekte
```javascript
const user = {
  name: "Max",
  adresse: {
    strasse: "Hauptstraße 1",
    stadt: "Berlin",
    plz: "10115"
  },
  hobbies: ["Lesen", "Sport"]
};

// Zugriff auf verschachtelte Properties
console.log(user.adresse.stadt); // "Berlin"
console.log(user.hobbies[0]); // "Lesen"

// Optional Chaining (ES2020)
const stadt = user?.adresse?.stadt; // "Berlin"
const fehler = user?.nichtVorhanden?.stadt; // undefined (kein Fehler!)
```

### Object Methods
```javascript
const person = { name: "Max", alter: 25 };

// Keys
console.log(Object.keys(person)); // ["name", "alter"]

// Values
console.log(Object.values(person)); // ["Max", 25]

// Entries
console.log(Object.entries(person)); // [["name", "Max"], ["alter", 25]]

// Assign (Merge)
const defaults = { theme: "dark", lang: "de" };
const settings = { lang: "en" };
const merged = Object.assign({}, defaults, settings);
// { theme: "dark", lang: "en" }

// Spread (besser)
const merged2 = { ...defaults, ...settings };
```

### Destructuring (ES6)
```javascript
const person = { name: "Max", alter: 25, stadt: "Berlin" };

// Objekt-Destructuring
const { name, alter } = person;
console.log(name); // "Max"
console.log(alter); // 25

// Mit Alias
const { name: personName, alter: age } = person;
console.log(personName); // "Max"
console.log(age); // 25

// Default-Werte
const { name, email = "keine@email" } = person;
console.log(email); // "keine@email"

// Verschachteltes Destructuring
const user = {
  name: "Max",
  adresse: { stadt: "Berlin", plz: "10115" }
};

const { adresse: { stadt, plz } } = user;
console.log(stadt); // "Berlin"
console.log(plz); // "10115"
```

### Map (ES6)
```javascript
// Map ist wie Object, aber mit beliebigen Keys
const map = new Map();

// Setzen
map.set("name", "Max");
map.set(1, "Zahl als Key");
map.set({ id: 1 }, "Objekt als Key");

// Get
console.log(map.get("name")); // "Max"
console.log(map.get(1)); // "Zahl als Key"

// Prüfen
console.log(map.has("name")); // true

// Größe
console.log(map.size); // 3

// Löschen
map.delete("name");

// Iteration
for (const [key, value] of map) {
  console.log(`${key}: ${value}`);
}

// Konvertierung
const obj = Object.fromEntries(map);
const map2 = new Map(Object.entries(obj));
```

### Set (ES6)
```javascript
// Set für einzigartige Werte
const set = new Set();

// Hinzufügen
set.add(1);
set.add(2);
set.add(1); // Wird ignoriert

console.log(set.size); // 2

// Prüfen
console.log(set.has(1)); // true

// Löschen
set.delete(1);

// Iteration
for (const value of set) {
  console.log(value);
}

// Konvertierung
const array = [...set]; // [2]
const set2 = new Set([1, 2, 3, 1, 2]); // {1, 2, 3}
```

{{ task(file="tasks/02_00_13.yaml") }}

---

## JSON (JavaScript Object Notation)

### Was ist JSON?
- **Textformat** für Datenaustausch
- **Basierend** auf JavaScript-Objekten
- **Einfach** und leichtgewichtig
- **Sprachunabhängig**

### JSON-Struktur
```json
{
  "name": "Max Mustermann",
  "alter": 25,
  "istAktiv": true,
  "hobbies": ["Lesen", "Sport"],
  "adresse": {
    "stadt": "Berlin",
    "plz": "10115"
  },
  "telefon": null
}
```

### JSON.parse & JSON.stringify
```javascript
// JSON-String zu JavaScript-Objekt
const jsonString = '{"name":"Max","alter":25}';
const objekt = JSON.parse(jsonString);
console.log(objekt.name); // "Max"

// JavaScript-Objekt zu JSON-String
const person = { name: "Max", alter: 25 };
const json = JSON.stringify(person);
console.log(json); // '{"name":"Max","alter":25}'

// Mit Formatierung
const pretty = JSON.stringify(person, null, 2);
console.log(pretty);
/*
{
  "name": "Max",
  "alter": 25
}
*/
```

### Fehlerbehandlung
```javascript
// Ungültiges JSON
try {
  const obj = JSON.parse('{"name":"Max"'); // Fehlende Klammer
} catch (fehler) {
  console.log("JSON-Fehler:", fehler.message);
}

// Mit Default-Wert
const obj = JSON.parse('{"name":"Max"}', (key, value) => {
  if (key === "alter") return value || 0; // Default 0
  return value;
});
```

### Praktische Beispiele

#### Beispiel 1: API-Daten verarbeiten
```javascript
async function ladeBenutzer() {
  try {
    const response = await fetch('https://api.example.com/users/1');
    const data = await response.json(); // JSON.parse automatisch

    console.log(`Benutzer: ${data.name}`);
    console.log(`Alter: ${data.alter}`);
    console.log(`Adresse: ${data.adresse.stadt}`);

    return data;
  } catch (fehler) {
    console.error("Fehler:", fehler);
  }
}
```

#### Beispiel 2: LocalStorage mit JSON
```javascript
// Speichern
const user = { name: "Max", theme: "dark" };
localStorage.setItem('user', JSON.stringify(user));

// Laden
const gespeichert = localStorage.getItem('user');
if (gespeichert) {
  const user = JSON.parse(gespeichert);
  console.log(user.name); // "Max"
}

// Löschen
localStorage.removeItem('user');
```

#### Beispiel 3: Konfiguration laden
```javascript
const config = {
  api: {
    baseUrl: "https://api.example.com",
    timeout: 5000
  },
  features: {
    darkMode: true,
    notifications: false
  }
};

// Speichern
localStorage.setItem('config', JSON.stringify(config));

// Laden mit Defaults
const gespeichert = localStorage.getItem('config');
const loadedConfig = gespeichert ? JSON.parse(gespeichert) : {};

// Merge mit Defaults
const finalConfig = {
  ...config,
  ...loadedConfig
};
```

{{ task(file="tasks/02_00_14.yaml") }}

---

## Häufige Fehler & Best Practices

### Fehler 1: Array-Referenzen
```javascript
// ❌ Falsch (Referenz-Kopie)
const arr1 = [1, 2, 3];
const arr2 = arr1; // arr2 ist Referenz auf arr1
arr2.push(4);
console.log(arr1); // [1, 2, 3, 4] (arr1 wurde auch geändert!)

// ✅ Gut (echte Kopie)
const arr1 = [1, 2, 3];
const arr2 = [...arr1]; // Spread Operator
arr2.push(4);
console.log(arr1); // [1, 2, 3] (arr1 bleibt unverändert)
```

### Fehler 2: Fehlende JSON-Validierung
```javascript
// ❌ Falsch (keine Fehlerbehandlung)
const obj = JSON.parse(userInput);

// ✅ Gut (mit try/catch)
let obj;
try {
  obj = JSON.parse(userInput);
} catch (fehler) {
  console.log("Ungültiges JSON");
  obj = {}; // Fallback
}
```

### Fehler 3: Zu viele verschachtelte Objekte
```javascript
// ❌ Schlecht (zu tief verschachtelt)
const data = {
  user: {
    profile: {
      address: {
        city: {
          name: "Berlin"
        }
      }
    }
  }
};

// ✅ Gut (flacher)
const data = {
  userName: "Max",
  city: "Berlin"
};
```

### Best Practices
1. **Spread Operator** für Kopien verwenden
2. **Destructuring** für sauberen Code
3. **Optional Chaining** für sichere Zugriffe
4. **JSON.parse** mit try/catch
5. **Map/Set** für spezielle Anforderungen
6. **Keine tiefen Verschachtelungen**
7. **Konsistente Namenskonventionen**

---

## Zusammenfassung & Checkliste

### Wichtige Konzepte
- ✅ **Arrays**: push, pop, map, filter, reduce, spread
- ✅ **Objekte**: Literal, Zugriff, Destructuring
- ✅ **Map/Set**: Moderne Datenstrukturen
- ✅ **JSON**: parse, stringify, Datenaustausch
- ✅ **Spread Operator**: Kopieren, Kombinieren
- ✅ **Destructuring**: Saubere Zuweisungen

### Checkliste für Code
- [ ] Spread Operator für Kopien
- [ ] Destructuring für Objekte/Arrays
- [ ] Optional Chaining für sichere Zugriffe
- [ ] JSON.parse mit try/catch
- [ ] Map/Set für spezielle Anforderungen
- [ ] Keine tiefen Verschachtelungen

---

## Nächste Schritte

Nachdem du diese Grundlagen beherrschst:
1. **Async/Await** - Asynchrone Programmierung
2. **Fetch API** - HTTP-Anfragen
3. **LocalStorage** - Daten im Browser speichern
4. **ES6 Modules** - Code modularisieren

**Empfohlene Ressourcen:**
- [MDN Web Docs - Arrays](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Array)
- [MDN Web Docs - Objects](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object)
- [MDN Web Docs - JSON](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/JSON)
- [JavaScript.info - Arrays](https://javascript.info/array)
