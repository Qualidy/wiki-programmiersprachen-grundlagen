# JavaScript Grundlagen 6 – Best Practices & Patterns

!!! abstract "Lernziele"
    Nach diesem Kapitel kannst du …

    - **Best Practices** für sauberen JavaScript-Code.
    - **Design Patterns** (Module, Factory, Observer) verstehen.
    - **Error Handling** robust implementieren.
    - **Performance-Optimierung** durchführen.
    - **Code-Qualität** mit Linting und Testing verbessern.

---

## Einführung

**Best Practices** sind etablierte Konventionen für:
- **Lesbarkeit**: Code ist leicht zu verstehen
- **Wartbarkeit**: Einfache Änderungen und Erweiterungen
- **Performance**: Effiziente Ausführung
- **Sicherheit**: Vermeidung von Fehlern und Angriffen

**Wichtige Fakten:**
- **Clean Code**: Robert C. Martin's Prinzipien
- **DRY**: Don't Repeat Yourself
- **KISS**: Keep It Simple, Stupid
- **YAGNI**: You Aren't Gonna Need It

---

## Code-Style & Konventionen

### Namenskonventionen
```javascript
// ✅ Gut: camelCase für Variablen/Funktionen
const benutzerName = "Max";
const alter = 25;

function berechneSumme(a, b) {
  return a + b;
}

// ✅ Gut: PascalCase für Klassen
class Benutzer {
  constructor(name) {
    this.name = name;
  }
}

// ✅ Gut: UPPER_CASE für Konstanten
const API_URL = "https://api.example.com";
const MAX_USERS = 100;

// ❌ Schlecht: Ungültige Namen
const x = 10; // Zu kurz, nicht beschreibend
const user_name = "Max"; // snake_case (nicht JS-Standard)
const PI = 3.14; // Konstante, aber nicht UPPER_CASE
```

### Kommentare & Dokumentation
```javascript
// ❌ Schlecht: Überflüssige Kommentare
const x = 10; // Setzt x auf 10

// ✅ Gut: Sinnvolle Kommentare
const maxUsers = 100; // Begrenzung für Rate-Limiting

// ✅ Gut: JSDoc für Funktionen
/**
 * Berechnet die Summe zweier Zahlen
 * @param {number} a - Erste Zahl
 * @param {number} b - Zweite Zahl
 * @returns {number} Summe von a und b
 */
function sum(a, b) {
  return a + b;
}

// ❌ Schlecht: Veraltete Kommentare
// TODO: Diese Funktion muss noch überarbeitet werden
// FIXME: Hier ist ein Bug
function alteFunktion() {
  // ... Code ...
}
```

### Formatierung
```javascript
// ✅ Gut: Einrückung (2 oder 4 Leerzeichen)
function beispiel() {
  if (condition) {
    // Code
  }
}

// ✅ Gut: Semikolons (optional, aber konsistent)
const x = 10;
const y = 20;

// ✅ Gut: Leerzeichen um Operatoren
const summe = a + b;
const ergebnis = (a + b) * c;

// ❌ Schlecht: Keine Leerzeichen
const summe=a+b;
const ergebnis=(a+b)*c;
```

---

## Design Patterns

### 1. Modul-Pattern (ES6 Modules)
```javascript
// math.js (Modul)
const PI = 3.14159;

function quadrat(x) {
  return x * x;
}

function kreisFlaeche(radius) {
  return PI * quadrat(radius);
}

// Export
export { PI, quadrat, kreisFlaeche };

// Oder: Named Export
export function add(a, b) {
  return a + b;
}

// Oder: Default Export
export default function berechne() {
  // ...
}
```

```javascript
// app.js (Import)
import { PI, quadrat, kreisFlaeche } from './math.js';
import berechne from './math.js';

console.log(PI); // 3.14159
console.log(kreisFlaeche(5)); // 78.5398
```

### 2. Factory Pattern
```javascript
// Factory für Benutzer
function benutzerFactory(name, rolle) {
  return {
    name,
    rolle,
    istAdmin: rolle === 'admin',
    getProfil() {
      return `${this.name} (${this.rolle})`;
    }
  };
}

// Verwendung
const admin = benutzerFactory('Max', 'admin');
const user = benutzerFactory('Anna', 'user');

console.log(admin.getProfil()); // "Max (admin)"
console.log(user.istAdmin); // false
```

### 3. Observer Pattern
```javascript
class Subject {
  constructor() {
    this.observers = [];
  }

  addObserver(observer) {
    this.observers.push(observer);
  }

  removeObserver(observer) {
    this.observers = this.observers.filter(obs => obs !== observer);
  }

  notify(data) {
    this.observers.forEach(observer => observer.update(data));
  }
}

class Observer {
  update(data) {
    console.log('Update erhalten:', data);
  }
}

// Verwendung
const subject = new Subject();
const observer1 = new Observer();
const observer2 = new Observer();

subject.addObserver(observer1);
subject.addObserver(observer2);

subject.notify('Neue Daten!'); // Beide Observer erhalten Update
```

### 4. Singleton Pattern
```javascript
class Database {
  constructor() {
    if (Database.instance) {
      return Database.instance;
    }

    this.connection = null;
    Database.instance = this;
  }

  connect() {
    if (!this.connection) {
      this.connection = 'Verbunden mit DB';
      console.log('Datenbank verbunden');
    }
    return this.connection;
  }
}

// Verwendung
const db1 = new Database();
const db2 = new Database();

db1.connect(); // "Datenbank verbunden"
db2.connect(); // Keine neue Verbindung

console.log(db1 === db2); // true (gleiche Instanz)
```

{{ task(file="tasks/02_00_15.yaml") }}

---

## Error Handling

### Try-Catch-Finally
```javascript
// Grundlegende Struktur
try {
  // Code, der fehlschlagen kann
  const result = JSON.parse('{"ungültig"');
} catch (fehler) {
  // Fehlerbehandlung
  console.error('Fehler:', fehler.message);
} finally {
  // Wird immer ausgeführt
  console.log('Aufräumen...');
}
```

### Custom Errors
```javascript
class ValidationError extends Error {
  constructor(message, field) {
    super(message);
    this.name = 'ValidationError';
    this.field = field;
  }
}

class NetworkError extends Error {
  constructor(message, status) {
    super(message);
    this.name = 'NetworkError';
    this.status = status;
  }
}

// Verwendung
function validateUser(user) {
  if (!user.name) {
    throw new ValidationError('Name fehlt', 'name');
  }
  if (user.age < 18) {
    throw new ValidationError('Zu jung', 'age');
  }
}

try {
  validateUser({ name: '', age: 16 });
} catch (fehler) {
  if (fehler instanceof ValidationError) {
    console.log(`Validierungsfehler: ${fehler.message} (${fehler.field})`);
  } else {
    throw fehler; // Weiterwerfen
  }
}
```

### Async Error Handling
```javascript
// Mit try/catch in async Funktion
async function ladeDaten() {
  try {
    const response = await fetch('https://api.example.com/data');

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }

    const data = await response.json();
    return data;
  } catch (fehler) {
    console.error('Fehler beim Laden:', fehler.message);

    // Fallback-Daten
    return { error: true, data: [] };
  }
}

// Mit Error Boundary (React-ähnlich)
class ErrorBoundary {
  constructor() {
    this.hasError = false;
  }

  catch(error) {
    this.hasError = true;
    console.error('ErrorBoundary:', error);
  }

  render(fallback) {
    return this.hasError ? fallback : null;
  }
}
```

### Graceful Degradation
```javascript
// Fallback für fehlende Features
function getGeolocation() {
  if (!navigator.geolocation) {
    return Promise.reject(new Error('Geolocation nicht unterstützt'));
  }

  return new Promise((resolve, reject) => {
    navigator.geolocation.getCurrentPosition(
      position => resolve(position),
      error => reject(error)
    );
  });
}

// Verwendung mit Fallback
getGeolocation()
  .then(position => {
    console.log('Position:', position);
  })
  .catch(error => {
    console.warn('Geolocation fehlgeschlagen:', error.message);
    // Fallback: IP-basierte Location
    return fetchIpLocation();
  })
  .then(location => {
    console.log('Standort (Fallback):', location);
  });
```

---

## Performance-Optimierung

### 1. Debouncing & Throttling
```javascript
// Debouncing: Ausführung nach letzter Aktion
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

// Throttling: Maximal einmal pro Zeitraum
function throttle(func, limit) {
  let inThrottle;
  return function(...args) {
    if (!inThrottle) {
      func(...args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}

// Verwendung
const searchInput = document.getElementById('search');
searchInput.addEventListener('input', debounce((e) => {
  console.log('Suche:', e.target.value);
}, 300));

window.addEventListener('scroll', throttle(() => {
  console.log('Scroll-Event');
}, 100));
```

### 2. Lazy Loading
```javascript
// Dynamisches Importieren
async function ladeModul() {
  const module = await import('./heavy-module.js');
  return module.default();
}

// Intersection Observer für Lazy Loading
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const img = entry.target;
      img.src = img.dataset.src;
      observer.unobserve(img);
    }
  });
});

document.querySelectorAll('img[data-src]').forEach(img => {
  observer.observe(img);
});
```

### 3. Memoization
```javascript
// Cache für teure Berechnungen
function memoize(fn) {
  const cache = new Map();

  return function(...args) {
    const key = JSON.stringify(args);

    if (cache.has(key)) {
      return cache.get(key);
    }

    const result = fn(...args);
    cache.set(key, result);
    return result;
  };
}

// Teure Funktion
function teureBerechnung(n) {
  console.log('Berechne...');
  return n * n;
}

const memoized = memoize(teureBerechnung);

console.log(memoized(5)); // Berechne... 25
console.log(memoized(5)); // 25 (aus Cache)
```

### 4. Web Workers (Parallelität)
```javascript
// worker.js
self.addEventListener('message', (e) => {
  const result = heavyCalculation(e.data);
  self.postMessage(result);
});

// Haupt-Thread
const worker = new Worker('worker.js');

worker.postMessage({ data: 'input' });

worker.onmessage = (e) => {
  console.log('Ergebnis vom Worker:', e.data);
};
```

---

## Testing

### 1. Unit Tests (Jest)
```javascript
// sum.js
function sum(a, b) {
  return a + b;
}

module.exports = sum;

// sum.test.js
const sum = require('./sum');

test('adds 1 + 2 to equal 3', () => {
  expect(sum(1, 2)).toBe(3);
});

test('adds 0 + 0 to equal 0', () => {
  expect(sum(0, 0)).toBe(0);
});
```

### 2. Integration Tests
```javascript
// api.test.js
const { fetchUser } = require('./api');

test('fetchUser returns user data', async () => {
  const user = await fetchUser(1);
  expect(user).toHaveProperty('id', 1);
  expect(user).toHaveProperty('name');
});

test('fetchUser handles errors', async () => {
  await expect(fetchUser(999)).rejects.toThrow('User not found');
});
```

### 3. E2E Tests (Playwright)
```javascript
// test.spec.js
const { test, expect } = require('@playwright/test');

test('login page', async ({ page }) => {
  await page.goto('https://example.com/login');

  await page.fill('#username', 'testuser');
  await page.fill('#password', 'password123');
  await page.click('button[type="submit"]');

  await expect(page).toHaveURL(/dashboard/);
});
```

---

## Linting & Formattierung

### ESLint
```javascript
// .eslintrc.js
module.exports = {
  env: {
    browser: true,
    es2021: true,
    node: true,
  },
  extends: [
    'eslint:recommended',
    'plugin:react/recommended',
  ],
  rules: {
    'no-console': 'warn',
    'no-unused-vars': 'error',
    'semi': ['error', 'always'],
  },
};
```

### Prettier
```javascript
// .prettierrc
{
  "semi": true,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "es5",
  "printWidth": 80
}
```

### Husky (Git Hooks)
```bash
# .husky/pre-commit
#!/bin/sh
npm run lint
npm run test
```

---

## Häufige Fehler & Best Patterns

### Fehler 1: Global Variables
```javascript
// ❌ Schlecht (pollutes global scope)
x = 10;

// ✅ Gut (strict mode)
'use strict';
const x = 10;
```

### Fehler 2: Callback Hell
```javascript
// ❌ Schlecht (Callback Hell)
getData(function(a) {
  getMoreData(a, function(b) {
    getMoreData(b, function(c) {
      // ...
    });
  });
});

// ✅ Gut (Promises/Async)
async function getDataChain() {
  const a = await getData();
  const b = await getMoreData(a);
  const c = await getMoreData(b);
  return c;
}
```

### Fehler 3: Memory Leaks
```javascript
// ❌ Schlecht (Event Listener nicht entfernt)
element.addEventListener('click', handler);

// ✅ Gut (removeEventListener)
element.addEventListener('click', handler);
// Später:
element.removeEventListener('click', handler);

// ✅ Gut (WeakMap für Cleanup)
const listeners = new WeakMap();
function addListener(element, handler) {
  listeners.set(element, handler);
  element.addEventListener('click', handler);
}
```

### Best Patterns
1. **Immutability** (const, Object.freeze)
2. **Pure Functions** (keine Seiteneffekte)
3. **Functional Programming** (map, filter, reduce)
4. **Async/Await** statt Callbacks
5. **Destructuring** für sauberen Code
6. **Template Literals** statt String-Konkatenation
7. **Optional Chaining** für sichere Zugriffe
8. **Nullish Coalescing** für Default-Werte

---

## Zusammenfassung & Checkliste

### Wichtige Konzepte
- ✅ **Namenskonventionen**: camelCase, PascalCase, UPPER_CASE
- ✅ **Design Patterns**: Module, Factory, Observer, Singleton
- ✅ **Error Handling**: Try/Catch, Custom Errors, Async
- ✅ **Performance**: Debouncing, Throttling, Lazy Loading
- ✅ **Testing**: Unit, Integration, E2E
- ✅ **Linting**: ESLint, Prettier, Husky

### Checkliste für Code
- [ ] Klare Namenskonventionen
- [ ] Sinnvolle Kommentare (JSDoc)
- [ ] Error Handling implementiert
- [ ] Performance optimiert
- [ ] Tests geschrieben
- [ ] Linting konfiguriert
- [ ] Keine globalen Variablen
- [ ] Kein Callback Hell

---

## Nächste Schritte

Nachdem du diese Grundlagen beherrschst:
1. **Advanced Patterns** - Decorator, Proxy, Generator
2. **TypeScript** - Statische Typisierung
3. **Build Tools** - Webpack, Vite, Babel
4. **Frameworks** - React, Vue, Angular

**Empfohlene Ressourcen:**
- [MDN Web Docs - JavaScript Guide](https://developer.mozilla.org/de/docs/Web/JavaScript/Guide)
- [JavaScript Patterns](https://www.patterns.dev/)
- [Clean Code JavaScript](https://github.com/ryanmcdermott/clean-code-javascript)
- [Jest Testing](https://jestjs.io/)
