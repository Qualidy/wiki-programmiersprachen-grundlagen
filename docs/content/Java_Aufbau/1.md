# Java Aufbau 1 – Streams & Lambdas

!!! abstract "Lernziele"
    Nach diesem Kapitel kannst du …

    - **Java Streams** zur Datenverarbeitung verwenden.
    - **Lambda-Ausdrücke** für funktionalen Programmierstil schreiben.
    - **Methoden-Referenzen** verstehen und anwenden.
    - **Stream-Operationen** (filter, map, collect) nutzen.
    - **Optional** für sichere Null-Verarbeitung einsetzen.

---

## Einführung

Java 8 hat die Programmierung revolutioniert mit **Streams** und **Lambdas**. Diese Features ermöglichen **funktionalen Programmierstil** in Java.

![Java 8 Logo](https://upload.wikimedia.org/wikipedia/commons/thumb/6/63/Java_logo.svg/300px-Java_logo.svg.png){ align=left width=300px }

**Wichtige Fakten:**
- Streams sind seit **Java 8** verfügbar (2014)
- Lambdas sind seit **Java 8** verfügbar
- Sie ermöglichen **deklarative Programmierung** (was, nicht wie)
- Bessere Lesbarkeit und weniger Boilerplate-Code

**Anwendungsbereiche:**
- Datenverarbeitung und Transformation
- Collection-Verarbeitung
- Parallelisierung von Operationen
- Funktionale Programmierung in Java

---

## Lambda-Ausdrücke

### Was sind Lambdas?
Lambda-Ausdrücke sind **anonyme Funktionen** (Funktionen ohne Namen).

### Syntax
```java
// Alt (mit anonymen Klasse)
Runnable r = new Runnable() {
    @Override
    public void run() {
        System.out.println("Hallo");
    }
};

// Neu (mit Lambda)
Runnable r = () -> System.out.println("Hallo");
```

### Struktur
```
(parameter) -> { Körperteil }
```

**Beispiele:**
```java
// 1. Ohne Parameter
() -> System.out.println("Hallo");

// 2. Ein Parameter (Klammern optional)
x -> x * x;

// 3. Mehrere Parameter
(a, b) -> a + b;

// 4. Mit Rückgabewert
(x, y) -> {
    int summe = x + y;
    return summe;
};
```

### Funktionalen Interfaces verwenden
Lambdas funktionieren mit **funktionalen Interfaces** (Interfaces mit genau einer abstrakten Methode):

```java
// Interface definieren
@FunctionalInterface
interface Berechner {
    int berechne(int a, int b);
}

// Lambda verwenden
Berechner addierer = (a, b) -> a + b;
Berechner multiplizierer = (a, b) -> a * b;

System.out.println(addierer.berechne(5, 3));      // 8
System.out.println(multiplizierer.berechne(5, 3)); // 15
```

### Bekannte funktionale Interfaces aus java.util.function

| Interface | Methode | Beschreibung |
|-----------|---------|--------------|
| `Predicate<T>` | `boolean test(T t)` | Prüft eine Bedingung |
| `Function<T,R>` | `R apply(T t)` | Transformiert T zu R |
| `Consumer<T>` | `void accept(T t)` | Verbraucht einen Wert |
| `Supplier<T>` | `T get()` | Liefert einen Wert |

```java
import java.util.function.Predicate;
import java.util.function.Function;
import java.util.function.Consumer;

// Predicate: Prüft, ob Zahl gerade ist
Predicate<Integer> istGerade = x -> x % 2 == 0;
System.out.println(istGerade.test(4)); // true

// Function: Quadrat einer Zahl
Function<Integer, Integer> quadrat = x -> x * x;
System.out.println(quadrat.apply(5)); // 25

// Consumer: Gibt Text aus
Consumer<String> ausgabe = text -> System.out.println("Ausgabe: " + text);
ausgabe.accept("Hallo");
```

---

## Streams

### Was sind Streams?
Streams sind **Sequenzen von Elementen**, die durch eine Pipeline verarbeitet werden können.

**Wichtige Eigenschaften:**
- **Keine Speicherung**: Streams speichern keine Daten
- **Lazy Evaluation**: Operationen werden nur bei Bedarf ausgeführt
- **Nicht veränderbar**: Original-Collection bleibt unverändert
- **Parallelisierbar**: Einfache Parallelverarbeitung

### Stream-Pipeline
```
Quelle → Filter → Map → Collect
```

### Quellen (Sources)
```java
// Aus Collection
List<String> liste = List.of("A", "B", "C");
Stream<String> stream = liste.stream();

// Aus Array
String[] array = {"A", "B", "C"};
Stream<String> stream = Arrays.stream(array);

// Erzeugen
Stream<String> stream = Stream.of("A", "B", "C");

// Range
IntStream zahlen = IntStream.range(1, 11); // 1 bis 10
```

---

## Stream-Operationen

### 1. Filter (Bedingungen prüfen)
```java
List<Integer> zahlen = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

// Nur gerade Zahlen
List<Integer> gerade = zahlen.stream()
    .filter(x -> x % 2 == 0)
    .collect(Collectors.toList());

System.out.println(gerade); // [2, 4, 6, 8, 10]
```

### 2. Map (Transformation)
```java
List<String> namen = List.of("Max", "Anna", "Tom");

// Alle Namen in Großbuchstaben
List<String> gross = namen.stream()
    .map(String::toUpperCase)
    .collect(Collectors.toList());

System.out.println(gross); // [MAX, ANNA, TOM]

// Quadratzahlen
List<Integer> quadratzahlen = zahlen.stream()
    .map(x -> x * x)
    .collect(Collectors.toList());

System.out.println(quadratzahlen); // [1, 4, 9, 16, 25, ...]
```

### 3. Limit & Skip
```java
List<Integer> zahlen = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

// Erste 5 Elemente
List<Integer> erste5 = zahlen.stream()
    .limit(5)
    .collect(Collectors.toList());

// Elemente 3-7
List<Integer> mittel = zahlen.stream()
    .skip(2)  // Überspringe die ersten 2
    .limit(5) // Nimm die nächsten 5
    .collect(Collectors.toList());
```

### 4. Sorted (Sortierung)
```java
List<String> namen = List.of("Tom", "Anna", "Max", "Lisa");

// Alphabetisch sortiert
List<String> sortiert = namen.stream()
    .sorted()
    .collect(Collectors.toList());

// Nach Länge sortiert
List<String> nachLaenge = namen.stream()
    .sorted((a, b) -> a.length() - b.length())
    .collect(Collectors.toList());
```

### 5. Distinct (Duplikate entfernen)
```java
List<Integer> mitDuplikaten = List.of(1, 2, 2, 3, 3, 3, 4);

List<Integer> ohneDuplikate = mitDuplikaten.stream()
    .distinct()
    .collect(Collectors.toList());

System.out.println(ohneDuplikate); // [1, 2, 3, 4]
```

### 6. ForEach (Terminal Operation)
```java
List<String> namen = List.of("Max", "Anna", "Tom");

namen.stream()
    .filter(name -> name.startsWith("A"))
    .forEach(name -> System.out.println(name));
```

### 7. Collect (Ergebnis sammeln)
```java
List<Integer> zahlen = List.of(1, 2, 3, 4, 5);

// In Liste
List<Integer> liste = zahlen.stream()
    .filter(x -> x > 2)
    .collect(Collectors.toList());

// In Set
Set<Integer> set = zahlen.stream()
    .collect(Collectors.toSet());

// In Map
Map<Integer, String> map = zahlen.stream()
    .collect(Collectors.toMap(
        x -> x,           // Key
        x -> "Nr: " + x   // Value
    ));
```

---

## Praktische Beispiele

### Beispiel 1: Filter & Transform
```java
import java.util.List;
import java.util.stream.Collectors;

public class StreamBeispiel {
    public static void main(String[] args) {
        List<String> namen = List.of("Max", "Anna", "Tom", "Lisa", "Peter");

        // Nur Namen mit mehr als 3 Buchstaben, in Großbuchstaben
        List<String> ergebnis = namen.stream()
            .filter(name -> name.length() > 3)
            .map(String::toUpperCase)
            .collect(Collectors.toList());

        System.out.println(ergebnis); // [ANNA, LISA, PETER]
    }
}
```

### Beispiel 2: Zahlen verarbeiten
```java
import java.util.List;
import java.util.stream.Collectors;

public class ZahlenVerarbeitung {
    public static void main(String[] args) {
        List<Integer> zahlen = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        // Summe aller geraden Zahlen
        int summe = zahlen.stream()
            .filter(x -> x % 2 == 0)
            .mapToInt(x -> x) // In IntStream
            .sum();

        System.out.println("Summe der geraden Zahlen: " + summe); // 30

        // Durchschnitt aller Zahlen
        double durchschnitt = zahlen.stream()
            .mapToDouble(x -> x)
            .average()
            .orElse(0.0);

        System.out.println("Durchschnitt: " + durchschnitt); // 5.5
    }
}
```

### Beispiel 3: Objekte verarbeiten
```java
import java.util.List;
import java.util.stream.Collectors;

class Person {
    String name;
    int alter;

    Person(String name, int alter) {
        this.name = name;
        this.alter = alter;
    }

    String getName() { return name; }
    int getAlter() { return alter; }
}

public class PersonenVerarbeitung {
    public static void main(String[] args) {
        List<Person> personen = List.of(
            new Person("Max", 25),
            new Person("Anna", 30),
            new Person("Tom", 20),
            new Person("Lisa", 35)
        );

        // Nur Personen über 25
        List<String> altePersonen = personen.stream()
            .filter(p -> p.getAlter() > 25)
            .map(p -> p.getName())
            .collect(Collectors.toList());

        System.out.println(altePersonen); // [Anna, Lisa]

        // Durchschnittsalter
        double durchschnitt = personen.stream()
            .mapToInt(Person::getAlter)
            .average()
            .orElse(0.0);

        System.out.println("Durchschnittsalter: " + durchschnitt); // 27.5
    }
}
```

---

## Optional (Null-Sicherheit)

### Was ist Optional?
`Optional` ist ein Container, der entweder einen Wert enthält oder leer ist. Es hilft, `NullPointerException` zu vermeiden.

```java
import java.util.Optional;

public class OptionalBeispiel {
    public static void main(String[] args) {
        // Optional mit Wert
        Optional<String> name = Optional.of("Max");

        // Optional leer
        Optional<String> leer = Optional.empty();

        // Prüfen, ob Wert vorhanden
        if (name.isPresent()) {
            System.out.println(name.get()); // Max
        }

        // Oder mit Lambda
        name.ifPresent(n -> System.out.println(n));

        // Oder mit Standardwert
        String ergebnis = name.orElse("Unbekannt"); // Max
        String ergebnis2 = leer.orElse("Unbekannt"); // Unbekannt

        // Oder mit Supplier
        String ergebnis3 = leer.orElseGet(() -> "Standard");
    }
}
```

### Optional mit Streams
```java
import java.util.List;
import java.util.Optional;

public class OptionalStream {
    public static void main(String[] args) {
        List<String> namen = List.of("Max", "Anna", "Tom");

        // FindFirst gibt Optional
        Optional<String> erstes = namen.stream()
            .filter(name -> name.startsWith("A"))
            .findFirst();

        erstes.ifPresent(name -> System.out.println("Gefunden: " + name));
    }
}
```

---

## Methoden-Referenzen

Methoden-Referenzen sind eine kurze Schreibweise für Lambdas.

### Syntax
```java
// Lambda
Function<String, String> upper = s -> s.toUpperCase();

// Methoden-Referenz
Function<String, String> upper = String::toUpperCase;
```

### Arten von Methoden-Referenzen

1. **Statische Methode**: `Klasse::methode`
```java
// Lambda
Function<Integer, Double> zuDouble = x -> Math.sqrt(x);

// Methoden-Referenz
Function<Integer, Double> zuDouble = Math::sqrt;
```

2. **Instanz-Methode eines Objekts**: `objekt::methode`
```java
String text = "Hallo";

// Lambda
Function<String, Integer> laenge = s -> s.length();

// Methoden-Referenz
Function<String, Integer> laenge = text::length;
```

3. **Instanz-Methode eines Parameters**: `Klasse::methode`
```java
// Lambda
BiFunction<String, Integer, String> sub = (s, i) -> s.substring(i);

// Methoden-Referenz
BiFunction<String, Integer, String> sub = String::substring;
```

4. **Konstruktor**: `Klasse::new`
```java
// Lambda
Supplier<List<String>> listeSupplier = () -> new ArrayList<>();

// Methoden-Referenz
Supplier<List<String>> listeSupplier = ArrayList::new;
```

### Beispiele
```java
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class MethodenReferenzen {
    public static void main(String[] args) {
        List<String> namen = Arrays.asList("Max", "Anna", "Tom");

        // 1. Statische Methode
        List<String> gross = namen.stream()
            .map(String::toUpperCase)
            .collect(Collectors.toList());

        // 2. Instanz-Methode
        namen.stream()
            .forEach(System.out::println);

        // 3. Konstruktor
        List<String> kopi = namen.stream()
            .collect(Collectors.toCollection(ArrayList::new));
    }
}
```

---

## Parallel-Streams

### Wann verwenden?
- **Große Datenmengen**
- **CPU-intensive Operationen**
- **Unabhängig voneinander**

```java
import java.util.List;
import java.util.stream.Collectors;

public class ParallelStream {
    public static void main(String[] args) {
        List<Integer> zahlen = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        // Sequenziell
        List<Integer> seq = zahlen.stream()
            .map(x -> x * x)
            .collect(Collectors.toList());

        // Parallel
        List<Integer> par = zahlen.parallelStream()
            .map(x -> x * x)
            .collect(Collectors.toList());
    }
}
```

---

## Häufige Fehler & Best Practices

### Fehler 1: Stream mehrfach verwenden
```java
// ❌ Falsch (Stream kann nur einmal verwendet werden)
Stream<Integer> stream = zahlen.stream();
List<Integer> gerade = stream.filter(x -> x % 2 == 0).collect(Collectors.toList());
List<Integer> ungerade = stream.filter(x -> x % 2 != 0).collect(Collectors.toList()); // FEHLER!

// ✅ Gut
List<Integer> gerade = zahlen.stream().filter(x -> x % 2 == 0).collect(Collectors.toList());
List<Integer> ungerade = zahlen.stream().filter(x -> x % 2 != 0).collect(Collectors.toList());
```

### Fehler 2: Null-Checks vergessen
```java
// ❌ Falsch (kann NullPointerException werfen)
Optional<String> opt = Optional.ofNullable(null);
String text = opt.get(); // FEHLER!

// ✅ Gut
opt.ifPresent(t -> System.out.println(t));
String text = opt.orElse("Standard");
```

### Best Practices
1. **Lambdas kurz halten** (maximal eine Zeile)
2. **Methoden-Referenzen** verwenden, wenn möglich
3. **Optional** für Rückgabewerte, die null sein können
4. **Parallel-Streams nur bei Bedarf** (Overhead!)
5. **Keine Seiteneffekte** in Lambdas (keine Änderungen externer Zustände)
6. **Collectoren** für komplexe Ergebnisse verwenden

---

## Zusammenfassung & Checkliste

### Wichtige Konzepte
- ✅ **Lambdas**: Anonyme Funktionen, `() -> {}`
- ✅ **Funktionale Interfaces**: `Predicate`, `Function`, `Consumer`, `Supplier`
- ✅ **Streams**: Pipeline zur Datenverarbeitung
- ✅ **Stream-Operationen**: `filter`, `map`, `collect`, `forEach`
- ✅ **Optional**: Null-Sicherheit
- ✅ **Methoden-Referenzen**: Kurzschreibweise für Lambdas
- ✅ **Parallel-Streams**: Für große Datenmengen

### Checkliste für Code
- [ ] Lambdas kurz und prägnant
- [ ] Methoden-Referenzen bevorzugen
- [ ] Optional für mögliche Null-Werte
- [ ] Keine Seiteneffekte in Streams
- [ ] Collectoren korrekt verwenden
- [ ] Parallel-Streams nur bei Bedarf

---

## Nächste Schritte

Nachdem du diese Grundlagen beherrschst:
1. **Advanced Streams** - flatMap, groupingBy, partitioningBy
2. **Collectors** - Komplexe Aggregationen
3. **CompletableFuture** - Asynchrone Programmierung
4. **Reactive Streams** - Projekt Reactor/RxJava

**Empfohlene Ressourcen:**
- [Oracle Java 8 Streams](https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html)
- [Java 8 in Action](https://www.manning.com/books/java-8-in-action)
- [Baeldung Streams](https://www.baeldung.com/java-streams)
