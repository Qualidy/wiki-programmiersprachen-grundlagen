# Java Aufbau 2 – Advanced Collections

!!! abstract "Lernziele"
    Nach diesem Kapitel kannst du …

    - **Java Collections Framework** im Detail verstehen.
    - **List, Set, Map** und ihre Implementierungen nutzen.
    - **Generics** für typsichere Collections verwenden.
    - **Streams** mit Collections kombinieren.
    - **Performance-Aspekte** verschiedener Collections verstehen.

---

## Einführung

Das **Java Collections Framework** bietet Datenstrukturen für die Speicherung und Verarbeitung von Daten. Es ist die Grundlage für fast jede Java-Anwendung.

**Wichtige Fakten:**
- **Java 1.2** eingeführt (1998)
- **Generics** seit Java 5 (2004)
- **Streams** seit Java 8 (2014)
- **Immutable Collections** seit Java 9 (2017)

**Hierarchie:**
```
Collection
├── List (geordnet, wiederholbar)
│   ├── ArrayList
│   ├── LinkedList
│   └── Vector
├── Set (ungeordnet, einzigartig)
│   ├── HashSet
│   ├── LinkedHashSet
│   └── TreeSet
└── Queue (Warteschlange)
    ├── PriorityQueue
    └── ArrayDeque
```

---

## List-Implementierungen

### ArrayList
**Eigenschaften:**
- **Dynamisches Array**
- **Schneller Zugriff** (O(1))
- **Langsames Einfügen/Löschen** in der Mitte (O(n))
- **Nicht synchronisiert** (schneller)

```java
import java.util.ArrayList;
import java.util.List;

List<String> namen = new ArrayList<>();

// Hinzufügen
namen.add("Max");
namen.add("Anna");
namen.add("Tom");

// An Position einfügen
namen.add(1, "Lisa"); // [Max, Lisa, Anna, Tom]

// Zugriff
String name = namen.get(0); // "Max"

// Größe
int size = namen.size(); // 4

// Iteration
for (String n : namen) {
    System.out.println(n);
}

// Stream
namen.stream()
    .filter(n -> n.startsWith("A"))
    .forEach(System.out::println);
```

### LinkedList
**Eigenschaften:**
- **Verkettete Liste** (Doppelt verknüpft)
- **Schnelles Einfügen/Löschen** an beliebiger Stelle (O(1))
- **Langsamer Zugriff** (O(n))
- **Implementiert Queue und Deque**

```java
import java.util.LinkedList;

LinkedList<String> liste = new LinkedList<>();

// Queue-Operationen
liste.addFirst("Erstes");
liste.addLast("Letztes");
liste.add("Zwischen"); // Am Ende

String erstes = liste.removeFirst(); // Entfernt und gibt zurück
String letztes = liste.getLast();

// Deque-Operationen
liste.push("Auf den Stapel"); // Stack
liste.pop(); // Vom Stapel entfernen
```

### Vector
**Eigenschaften:**
- **Synchronisiert** (Thread-sicher)
- **Ältere Klasse** (seit Java 1.0)
- **Langsamer** als ArrayList
- **Heutzutage**: ArrayList mit Synchronisation verwenden

```java
import java.util.Vector;

Vector<String> vektor = new Vector<>();

// Thread-sicher
vektor.add("Element");
String element = vektor.get(0);
```

{{ task(file="tasks/05_00_03.yaml") }}

---

## Set-Implementierungen

### HashSet
**Eigenschaften:**
- **Hash-basiert** (HashMap-Wrapper)
- **Keine Garantie** für Reihenfolge
- **Schnelle Operationen** (O(1) average)
- **Erfordert korrekte hashCode() und equals()**

```java
import java.util.HashSet;
import java.util.Set;

Set<Integer> zahlen = new HashSet<>();

// Einzigartige Werte
zahlen.add(1);
zahlen.add(2);
zahlen.add(1); // Wird ignoriert

System.out.println(zahlen.size()); // 2

// Iteration
for (Integer z : zahlen) {
    System.out.println(z);
}
```

### LinkedHashSet
**Eigenschaften:**
- **Hash-basiert** mit **Einfügereihenfolge**
- **Schnelle Operationen** (O(1))
- **Gut für LRU-Caches**

```java
import java.util.LinkedHashSet;

Set<String> sortierteNamen = new LinkedHashSet<>();

sortierteNamen.add("Max");
sortierteNamen.add("Anna");
sortierteNamen.add("Tom");

// Reihenfolge bleibt erhalten
for (String name : sortierteNamen) {
    System.out.println(name); // Max, Anna, Tom
}
```

### TreeSet
**Eigenschaften:**
- **Balancierter Baum** (Red-Black Tree)
- **Sortierte Reihenfolge**
- **Schnelle Suche** (O(log n))
- **Erfordert Comparable oder Comparator**

```java
import java.util.TreeSet;

Set<Integer> sortierteZahlen = new TreeSet<>();

sortierteZahlen.add(5);
sortierteNamen.add(3);
sortierteNamen.add(8);
sortierteNamen.add(1);

// Automatisch sortiert
for (Integer z : sortierteZahlen) {
    System.out.println(z); // 1, 3, 5, 8
}

// Mit Custom Comparator
Set<String> namen = new TreeSet<>((a, b) -> b.length() - a.length());
namen.add("Max");
namen.add("Anna");
namen.add("Tom");
// Sortiert nach Länge absteigend
```

---

## Map-Implementierungen

### HashMap
**Eigenschaften:**
- **Hash-basiert** (Key-Value Paare)
- **Keine Garantie** für Reihenfolge
- **Schnelle Operationen** (O(1) average)
- **Erfordert korrekte hashCode() und equals() für Keys**

```java
import java.util.HashMap;
import java.util.Map;

Map<String, Integer> alter = new HashMap<>();

// Einfügen
alter.put("Max", 25);
alter.put("Anna", 30);
alter.put("Tom", 20);

// Zugriff
Integer maxAlter = alter.get("Max"); // 25
Integer lisaAlter = alter.get("Lisa"); // null

// Prüfen
boolean exists = alter.containsKey("Max"); // true
boolean hasValue = alter.containsValue(25); // true

// Iteration
for (Map.Entry<String, Integer> entry : alter.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}

// Stream
alter.entrySet().stream()
    .filter(e -> e.getValue() > 25)
    .forEach(e -> System.out.println(e.getKey()));
```

### LinkedHashMap
**Eigenschaften:**
- **Hash-basiert** mit **Einfügereihenfolge**
- **Gut für Caches** (LRU)
- **Performance wie HashMap**

```java
import java.util.LinkedHashMap;

Map<String, Integer> sortiertesAlter = new LinkedHashMap<>();

sortiertesAlter.put("Max", 25);
sortiertesAlter.put("Anna", 30);
sortiertesAlter.put("Tom", 20);

// Reihenfolge bleibt erhalten
for (Map.Entry<String, Integer> entry : sortiertesAlter.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}
```

### TreeMap
**Eigenschaften:**
- **Balancierter Baum** (Red-Black Tree)
- **Sortiert nach Keys**
- **Schnelle Suche** (O(log n))
- **Erfordert Comparable oder Comparator**

```java
import java.util.TreeMap;

Map<String, Integer> sortiertesAlter = new TreeMap<>();

sortiertesAlter.put("Max", 25);
sortiertesAlter.put("Anna", 30);
sortiertesAlter.put("Tom", 20);

// Automatisch nach Key sortiert
for (Map.Entry<String, Integer> entry : sortiertesAlter.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
    // Anna: 30, Max: 25, Tom: 20
}

// Teilbereiche
Map<String, Integer> teil = sortiertesAlter.subMap("A", "M");
```

### ConcurrentHashMap
**Eigenschaften:**
- **Thread-sichere** HashMap
- **Hochskalierbar** (Segmentierung)
- **Bessere Performance** als synchronized Map

```java
import java.util.concurrent.ConcurrentHashMap;

ConcurrentHashMap<String, Integer> concurrentMap = new ConcurrentHashMap<>();

// Thread-sicher
concurrentMap.put("Max", 25);
concurrentMap.put("Anna", 30);

// Parallel-Stream
concurrentMap.entrySet().parallelStream()
    .forEach(e -> System.out.println(e.getKey()));
```

---

## Generics

### Was sind Generics?
**Generics** ermöglichen **typsichere Collections** ohne Casting.

```java
// Ohne Generics (alt)
List liste = new ArrayList();
liste.add("Hallo");
String text = (String) liste.get(0); // Casting nötig

// Mit Generics (modern)
List<String> liste = new ArrayList<>();
liste.add("Hallo");
String text = liste.get(0); // Kein Casting nötig
```

### Typ-Parameter
```java
// Einfacher Typ
List<String> namen = new ArrayList<>();

// Komplexer Typ
Map<String, List<Integer>> daten = new HashMap<>();

// Wildcards
List<?> beliebig = new ArrayList<String>(); // Beliebiger Typ
List<? extends Number> zahlen = new ArrayList<Integer>(); // Number oder Subtyp
List<? super Integer> objekte = new ArrayList<Object>(); // Integer oder Supertyp
```

### Eigene Generics
```java
public class Box<T> {
    private T inhalt;

    public void setInhalt(T inhalt) {
        this.inhalt = inhalt;
    }

    public T getInhalt() {
        return inhalt;
    }
}

// Verwendung
Box<String> stringBox = new Box<>();
stringBox.setInhalt("Hallo");

Box<Integer> intBox = new Box<>();
intBox.setInhalt(42);
```

---

## Collections mit Streams

### Filter & Transform
```java
List<String> namen = Arrays.asList("Max", "Anna", "Tom", "Lisa");

// Nur Namen mit mehr als 3 Buchstaben
List<String> ergebnis = namen.stream()
    .filter(n -> n.length() > 3)
    .collect(Collectors.toList());

// In Map umwandeln
Map<String, Integer> laengen = namen.stream()
    .collect(Collectors.toMap(
        n -> n,
        n -> n.length()
    ));
```

### Gruppierung
```java
class Person {
    String name;
    int alter;
    String stadt;
    // Konstruktor, Getter...
}

List<Person> personen = // ...

// Nach Stadt gruppieren
Map<String, List<Person>> nachStadt = personen.stream()
    .collect(Collectors.groupingBy(Person::getStadt));

// Nach Alter gruppieren (Ranges)
Map<String, List<Person>> nachAlter = personen.stream()
    .collect(Collectors.groupingBy(p -> {
        if (p.getAlter() < 18) return "Jugendlich";
        else if (p.getAlter() < 65) return "Erwachsen";
        else return "Senior";
    }));
```

### Aggregation
```java
// Summe
int summe = personen.stream()
    .mapToInt(Person::getAlter)
    .sum();

// Durchschnitt
double durchschnitt = personen.stream()
    .mapToInt(Person::getAlter)
    .average()
    .orElse(0.0);

// Min/Max
int minAlter = personen.stream()
    .mapToInt(Person::getAlter)
    .min()
    .orElse(0);

int maxAlter = personen.stream()
    .mapToInt(Person::getAlter)
    .max()
    .orElse(0);
```

### Collectors
```java
// In Liste
List<String> liste = namen.stream()
    .collect(Collectors.toList());

// In Set
Set<String> set = namen.stream()
    .collect(Collectors.toSet());

// In Map
Map<String, Integer> map = namen.stream()
    .collect(Collectors.toMap(
        n -> n,
        n -> n.length()
    ));

// Joining
String kombiniert = namen.stream()
    .collect(Collectors.joining(", "));

// Counting
long anzahl = namen.stream()
    .collect(Collectors.counting());
```

{{ task(file="tasks/05_00_04.yaml") }}

---

## Performance-Vergleich

| Collection | Zugriff | Einfügen | Löschen | Speicher | Thread-Sicher | Sortiert |
|------------|---------|----------|---------|----------|---------------|----------|
| **ArrayList** | O(1) | O(1) am Ende, O(n) Mitte | O(n) | Niedrig | Nein | Nein |
| **LinkedList** | O(n) | O(1) | O(1) | Hoch | Nein | Nein |
| **HashSet** | O(1) avg | O(1) | O(1) | Mittel | Nein | Nein |
| **TreeSet** | O(log n) | O(log n) | O(log n) | Hoch | Nein | Ja |
| **HashMap** | O(1) avg | O(1) | O(1) | Mittel | Nein | Nein |
| **TreeMap** | O(log n) | O(log n) | O(log n) | Hoch | Nein | Ja |
| **ConcurrentHashMap** | O(1) avg | O(1) | O(1) | Mittel | Ja | Nein |

### Wann welche Collection?
- **ArrayList**: Standard-Liste, schneller Zugriff
- **LinkedList**: Häufiges Einfügen/Löschen in Mitte
- **HashSet**: Einzigartige Werte, schnelle Suche
- **TreeSet**: Sortierte Einzigartigkeit
- **HashMap**: Key-Value Paare, schnelle Suche
- **TreeMap**: Sortierte Key-Value Paare
- **ConcurrentHashMap**: Thread-sichere Map

---

## Häufige Fehler & Best Practices

### Fehler 1: Fehlende hashCode/equals
```java
// ❌ Falsch (keine hashCode/equals)
class Person {
    String name;
    int alter;
}

Set<Person> personen = new HashSet<>();
personen.add(new Person("Max", 25));
personen.add(new Person("Max", 25)); // Wird als NEU hinzugefügt!

// ✅ Gut
class Person {
    String name;
    int alter;

    @Override
    public int hashCode() {
        return Objects.hash(name, alter);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof Person)) return false;
        Person other = (Person) obj;
        return Objects.equals(name, other.name) && alter == other.alter;
    }
}
```

### Fehler 2: ConcurrentModificationException
```java
// ❌ Falsch (Modifikation während Iteration)
List<String> liste = new ArrayList<>(Arrays.asList("A", "B", "C"));
for (String item : liste) {
    if (item.equals("B")) {
        liste.remove(item); // Exception!
    }
}

// ✅ Gut (Iterator verwenden)
Iterator<String> it = liste.iterator();
while (it.hasNext()) {
    String item = it.next();
    if (item.equals("B")) {
        it.remove(); // Korrekt
    }
}
```

### Fehler 3: Null in Collections
```java
// ❌ Falsch (HashMap erlaubt null Keys)
Map<String, Integer> map = new HashMap<>();
map.put(null, 0); // Erlaubt, aber riskant

// ✅ Gut (TreeMap verhindert null)
Map<String, Integer> map = new TreeMap<>();
// map.put(null, 0); // NullPointerException!

// Oder: Explizite Prüfung
if (key != null) {
    map.put(key, value);
}
```

### Best Practices
1. **Generics immer verwenden** für Typsicherheit
2. **Collection-Interface** statt konkrete Klasse deklarieren
3. **Streams für komplexe Operationen**
4. **Immutable Collections** (Java 9+) für Konstanten
5. **Null-Checks** vor Zugriff
6. **Performance bewusst wählen**

---

## Zusammenfassung & Checkliste

### Wichtige Konzepte
- ✅ **List**: Geordnet, wiederholbar (ArrayList, LinkedList)
- ✅ **Set**: Einzigartig, ungeordnet (HashSet, TreeSet)
- ✅ **Map**: Key-Value Paare (HashMap, TreeMap)
- ✅ **Generics**: Typsicherheit ohne Casting
- ✅ **Streams**: Funktionale Verarbeitung
- ✅ **Collectors**: Ergebnisse sammeln

### Checkliste für Collections
- [ ] Generics korrekt verwendet
- [ ] hashCode/equals bei Sets/Maps
- [ ] Richtige Collection gewählt
- [ ] Null-Checks implementiert
- [ ] Streams für komplexe Logik
- [ ] Performance bewusst

---

## Nächste Schritte

Nachdem du diese Grundlagen beherrschst:
1. **Exception Handling** - Fehlerbehandlung
2. **Date/Time API** - Datum und Zeit
3. **File I/O** - Dateizugriff
4. **Multithreading** - Parallele Verarbeitung

**Empfohlene Ressourcen:**
- [Oracle Java Collections](https://docs.oracle.com/javase/tutorial/collections/)
- [Java Collections Framework](https://www.baeldung.com/java-collections)
- [JavaRanch Collections](https://coderanch.com/wiki/660256-Collections)
