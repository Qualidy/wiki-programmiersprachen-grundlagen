# Java Grundlagen 6 – Lösungsblatt: Design Patterns

!!! abstract "Lernziele"
    Nach diesem Kapitel kannst du …

    - **Lösungen** zu Design Pattern Übungen verstehen
    - **Best Practices** für Pattern-Implementierung erkennen
    - **Fehlerquellen** in Pattern-Implementierungen identifizieren
    - **Pattern-Varianten** vergleichen und anpassen

---

## Einführung

Dieses Lösungsblatt enthält die vollständigen Lösungen zu den Design Pattern Übungen aus **Java Grundlagen 5**.

**Wichtiger Hinweis:** Versuche zuerst, die Übungen selbstständig zu lösen, bevor du die Lösungen ansiehst!

---

## Lösung 1: Singleton Pattern

### Implementierung

```java
public class DatabaseConnection {
    // Private statische Instanzvariable
    private static DatabaseConnection instance;

    // Privater Konstruktor (verhindert direkte Instanziierung)
    private DatabaseConnection() {
        System.out.println("Datenbankverbindung erstellt");
    }

    // Public statische Methode zum Zugriff auf die Instanz
    public static DatabaseConnection getInstance() {
        if (instance == null) {
            instance = new DatabaseConnection();
        }
        return instance;
    }

    // Methode zur Verbindung
    public void connect() {
        System.out.println("Verbunden zur Datenbank");
    }
}

// Verwendung
public class Main {
    public static void main(String[] args) {
        DatabaseConnection db1 = DatabaseConnection.getInstance();
        DatabaseConnection db2 = DatabaseConnection.getInstance();

        db1.connect();  // Beide zeigen dieselbe Instanz
        db2.connect();

        System.out.println("db1 == db2: " + (db1 == db2)); // true
    }
}
```

### Erklärung

**Schlüsselkonzepte:**
1. **Private statische Variable** `instance` - speichert die einzige Instanz
2. **Privater Konstruktor** - verhindert `new DatabaseConnection()` von außen
3. **Public static `getInstance()`** - einziger Zugangspunkt zur Instanz
4. **Lazy Initialization** - Instanz wird erst beim ersten Aufruf erstellt

**Ausgabe:**
```
Datenbankverbindung erstellt
Verbunden zur Datenbank
Verbunden zur Datenbank
db1 == db2: true
```

### Häufige Fehler

❌ **Falsch:** Öffentlicher Konstruktor
```java
public DatabaseConnection() { ... }  // ❌ Erlaubt direkte Instanziierung
```

✅ **Richtig:** Privater Konstruktor
```java
private DatabaseConnection() { ... }  // ✅ Nur getInstance() kann Instanz erstellen
```

---

## Lösung 2: Factory Pattern

### Implementierung

```java
// Abstrakte Basis-Klasse
abstract class Fahrzeug {
    public abstract void fahre();

    public String getInfo() {
        return "Ich bin ein: " + this.getClass().getSimpleName();
    }
}

// Konkrete Klasse Auto
class Auto extends Fahrzeug {
    @Override
    public void fahre() {
        System.out.println("Auto fährt auf der Straße");
    }
}

// Konkrete Klasse Motorrad
class Motorrad extends Fahrzeug {
    @Override
    public void fahre() {
        System.out.println("Motorrad fährt auf der Straße");
    }
}

// Factory-Klasse
class FahrzeugFactory {
    public static Fahrzeug erstelleFahrzeug(String typ) {
        if (typ == null) {
            return null;
        }
        switch (typ.toLowerCase()) {
            case "auto":
                return new Auto();
            case "motorrad":
                return new Motorrad();
            default:
                return null;
        }
    }
}

// Verwendung
public class Main {
    public static void main(String[] args) {
        Fahrzeug auto = FahrzeugFactory.erstelleFahrzeug("auto");
        Fahrzeug motorrad = FahrzeugFactory.erstelleFahrzeug("motorrad");

        if (auto != null) {
            System.out.println(auto.getInfo());
            auto.fahre();
        }

        if (motorrad != null) {
            System.out.println(motorrad.getInfo());
            motorrad.fahre();
        }
    }
}
```

### Erklärung

**Schlüsselkonzepte:**
1. **Abstrakte Klasse** `Fahrzeug` - definiert gemeinsames Interface
2. **Konkrete Klassen** `Auto` und `Motorrad` - implementieren Interface
3. **Factory-Klasse** `FahrzeugFactory` - kapselt Erstellungslogik
4. **Client** verwendet Factory, ohne konkrete Klassen zu kennen

**Ausgabe:**
```
Ich bin ein: Auto
Auto fährt auf der Straße
Ich bin ein: Motorrad
Motorrad fährt auf der Straße
```

### Erweiterungsmöglichkeiten

**Factory mit Registry:**
```java
class FahrzeugFactory {
    private static Map<String, Supplier<Fahrzeug>> registry = new HashMap<>();

    static {
        registry.put("auto", Auto::new);
        registry.put("motorrad", Motorrad::new);
    }

    public static Fahrzeug erstelleFahrzeug(String typ) {
        Supplier<Fahrzeug> supplier = registry.get(typ.toLowerCase());
        return supplier != null ? supplier.get() : null;
    }
}
```

---

## Lösung 3: Observer Pattern

### Implementierung

```java
import java.util.ArrayList;
import java.util.List;

// Observer-Interface
interface Observer {
    void update(String message);
}

// Subject (Observable) - Basis-Klasse
abstract class Subject {
    private List<Observer> observers = new ArrayList<>();

    public void addObserver(Observer observer) {
        observers.add(observer);
    }

    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }

    public void notifyObservers(String message) {
        for (Observer observer : observers) {
            observer.update(message);
        }
    }
}

// Konkrete Subject-Klasse
class WetterStation extends Subject {
    public void setzeWetter(String wetter) {
        System.out.println("Wetterstation: Wetter wird aktualisiert zu: " + wetter);
        notifyObservers(wetter);
    }
}

// Konkrete Observer-Klassen
class Smartphone implements Observer {
    @Override
    public void update(String message) {
        System.out.println("Smartphone: Wetter geändert zu: " + message);
    }
}

class Webseite implements Observer {
    @Override
    public void update(String message) {
        System.out.println("Webseite: Wetter geändert zu: " + message);
    }
}

// Verwendung
public class Main {
    public static void main(String[] args) {
        WetterStation wetterStation = new WetterStation();

        Smartphone smartphone = new Smartphone();
        Webseite webseite = new Webseite();

        wetterStation.addObserver(smartphone);
        wetterStation.addObserver(webseite);

        wetterStation.setzeWetter("Sonnig");
        System.out.println("---");
        wetterStation.setzeWetter("Regnerisch");

        // Observer entfernen
        wetterStation.removeObserver(smartphone);
        System.out.println("---");
        wetterStation.setzeWetter("Bewölkt");
    }
}
```

### Erklärung

**Schlüsselkonzepte:**
1. **Observer-Interface** - definiert die Update-Methode
2. **Subject-Klasse** - verwaltet eine Liste von Observern
3. **Observer können dynamisch** hinzugefügt/entfernt werden
4. **Bei Änderungen** werden alle Observer benachrichtigt

**Ausgabe:**
```
Wetterstation: Wetter wird aktualisiert zu: Sonnig
Smartphone: Wetter geändert zu: Sonnig
Webseite: Wetter geändert zu: Sonnig
---
Wetterstation: Wetter wird aktualisiert zu: Regnerisch
Smartphone: Wetter geändert zu: Regnerisch
Webseite: Wetter geändert zu: Regnerisch
---
Wetterstation: Wetter wird aktualisiert zu: Bewölkt
Webseite: Wetter geändert zu: Bewölkt
```

### Anwendungsfälle

- **Event-Systeme** in GUI-Frameworks
- **Publish-Subscribe** in Messaging-Systemen
- **Model-View-Controller (MVC)** - View als Observer
- **Logging-Systeme** - mehrere Logger als Observer

---

## Lösung 4: Strategy Pattern

### Implementierung

```java
// Strategy-Interface
interface Zahlungsstrategie {
    void zahle(double betrag);
}

// Konkrete Strategien
class Kreditkarte implements Zahlungsstrategie {
    @Override
    public void zahle(double betrag) {
        System.out.printf("Zahle %.2f € mit Kreditkarte%n", betrag);
    }
}

class PayPal implements Zahlungsstrategie {
    @Override
    public void zahle(double betrag) {
        System.out.printf("Zahle %.2f € mit PayPal%n", betrag);
    }
}

class Barzahlung implements Zahlungsstrategie {
    @Override
    public void zahle(double betrag) {
        System.out.printf("Zahle %.2f € bar%n", betrag);
    }
}

// Kontext-Klasse
class Warenkorb {
    private Zahlungsstrategie strategie;

    public void setzeStrategie(Zahlungsstrategie strategie) {
        this.strategie = strategie;
        System.out.println("Zahlungsmethode gewechselt zu: " +
            strategie.getClass().getSimpleName());
    }

    public void bezahlen(double betrag) {
        if (strategie != null) {
            strategie.zahle(betrag);
        } else {
            System.out.println("Keine Zahlungsmethode ausgewählt!");
        }
    }
}

// Verwendung
public class Main {
    public static void main(String[] args) {
        Warenkorb warenkorb = new Warenkorb();

        // Erste Zahlung mit Kreditkarte
        warenkorb.setzeStrategie(new Kreditkarte());
        warenkorb.bezahlen(99.99);

        System.out.println("---");

        // Zweite Zahlung mit PayPal
        warenkorb.setzeStrategie(new PayPal());
        warenkorb.bezahlen(49.50);

        System.out.println("---");

        // Dritte Zahlung bar
        warenkorb.setzeStrategie(new Barzahlung());
        warenkorb.bezahlen(10.00);
    }
}
```

### Erklärung

**Schlüsselkonzepte:**
1. **Strategy-Interface** - definiert das gemeinsame Verhalten
2. **Konkrete Strategien** - implementieren unterschiedliche Algorithmen
3. **Kontext-Klasse** - verwendet eine Strategie-Instanz
4. **Laufzeit-Austausch** - Strategie kann gewechselt werden

**Ausgabe:**
```
Zahlungsmethode gewechselt zu: Kreditkarte
Zahle 99.99 € mit Kreditkarte
---
Zahlungsmethode gewechselt zu: PayPal
Zahle 49.50 € mit PayPal
---
Zahlungsmethode gewechselt zu: Barzahlung
Zahle 10.00 € bar
```

### Erweiterungsmöglichkeiten

**Strategie mit Kontext-Information:**
```java
interface Zahlungsstrategie {
    void zahle(double betrag, Warenkorb kontext);
}

class Kreditkarte implements Zahlungsstrategie {
    @Override
    public void zahle(double betrag, Warenkorb kontext) {
        System.out.printf("Zahle %.2f € mit Kreditkarte (Rabatt: %.2f €)%n",
            betrag, kontext.getRabatt());
    }
}
```

---

## Lösung 5: Adapter Pattern

### Implementierung

```java
// Alte Klasse (Adaptee)
class AlteDatenbank {
    public String holeDaten() {
        return "Alte Daten aus Datenbank";
    }
}

// Neues Interface (Target)
interface NeueDatenquelle {
    String ladeDaten();
}

// Adapter
class DatenbankAdapter implements NeueDatenquelle {
    private AlteDatenbank alteDatenbank;

    public DatenbankAdapter(AlteDatenbank alteDatenbank) {
        this.alteDatenbank = alteDatenbank;
    }

    @Override
    public String ladeDaten() {
        // Adapter übersetzt den Aufruf
        return alteDatenbank.holeDaten();
    }
}

// Neue Klasse, die das neue Interface verwendet
class DatenVerarbeiter {
    public void verarbeiteDaten(NeueDatenquelle datenquelle) {
        String daten = datenquelle.ladeDaten();
        System.out.println("Verarbeite: " + daten);
    }
}

// Verwendung
public class Main {
    public static void main(String[] args) {
        // Alte Datenbank
        AlteDatenbank alteDB = new AlteDatenbank();

        // Adapter erstellen
        NeueDatenquelle adapter = new DatenbankAdapter(alteDB);

        // Neue Klasse verwendet den Adapter
        DatenVerarbeiter verarbeiter = new DatenVerarbeiter();
        verarbeiter.verarbeiteDaten(adapter);

        // Direkter Aufruf des Adapters
        System.out.println("Adapter liefert: " + adapter.ladeDaten());
    }
}
```

### Erklärung

**Schlüsselkonzepte:**
1. **Alte Klasse** - existierender Code, der nicht geändert werden soll
2. **Neues Interface** - gewünschte neue Schnittstelle
3. **Adapter** - übersetzt Aufrufe zwischen altem und neuem Interface
4. **Client** verwendet neues Interface, ohne alte Klasse zu kennen

**Ausgabe:**
```
Verarbeite: Alte Daten aus Datenbank
Adapter liefert: Alte Daten aus Datenbank
```

### Anwendungsfälle

- **API-Migration** - alte APIs an neue Schnittstellen anpassen
- **Bibliotheks-Integration** - externe Bibliotheken integrieren
- **Legacy-Systeme** - alte Systeme in neue Architekturen einbinden
- **Datenkonvertierung** - unterschiedliche Datenformate anpassen

---

## Vergleich der Pattern

### Gemeinsamkeiten

| Pattern | Verwandtschaft | Unterschied |
|---------|----------------|-------------|
| **Singleton + Factory** | Beide erzeugen Objekte | Singleton: nur eine Instanz, Factory: viele Instanzen |
| **Observer + Strategy** | Beide nutzen Interfaces | Observer: Benachrichtigung, Strategy: Algorithmen |
| **Adapter + Factory** | Beide kapseln Komplexität | Adapter: Kompatibilität, Factory: Erstellung |

### Wann welches Pattern?

**Singleton:**
- ✅ Globale Ressourcen (Logger, Konfiguration)
- ✅ Thread-Safe Implementierung nötig
- ❌ Nicht für viele Instanzen

**Factory:**
- ✅ Flexible Objekterstellung
- ✅ Abhängigkeiten reduzieren
- ❌ Nicht für einfache Fälle

**Observer:**
- ✅ Event-Handling
- ✅ Publish-Subscribe
- ❌ Nicht für direkte Kommunikation

**Strategy:**
- ✅ Austauschbare Algorithmen
- ✅ Laufzeit-Entscheidungen
- ❌ Nicht für statische Verhalten

**Adapter:**
- ✅ Kompatibilität
- ✅ Migration
- ❌ Nicht für neue Entwicklung

---

## Best Practices

### Code-Qualität

**✅ Do's:**
```java
// Klare Namenskonventionen
class DatabaseSingleton { ... }  // ✅ Klarer Zweck
class PaymentStrategy { ... }    // ✅ Beschreibend
```

**❌ Don'ts:**
```java
// Unklare Namen
class MyClass { ... }            // ❌ Was macht es?
class Util { ... }               // ❌ Zu allgemein
```

### Fehlertoleranz

```java
// Defensive Programming
public static DatabaseConnection getInstance() {
    if (instance == null) {
        synchronized (DatabaseConnection.class) {  // Thread-Safe
            if (instance == null) {
                instance = new DatabaseConnection();
            }
        }
    }
    return instance;
}
```

### Dokumentation

```java
/**
 * Singleton Pattern für Datenbankverbindungen.
 * Sicherstellt, dass nur eine Verbindung pro JVM existiert.
 * Thread-Safe Implementierung mit Double-Checked Locking.
 */
public class DatabaseConnection {
    // ...
}
```

---

## Zusammenfassung

### Wichtige Erkenntnisse

1. **Singleton** - Kontrolliert Instanzanzahl, ideal für globale Ressourcen
2. **Factory** - Kapselt Erstellungslogik, fördert Loose Coupling
3. **Observer** - Implementiert Publish-Subscribe, dynamische Abonnenten
4. **Strategy** - Ermöglicht Algorithmen-Austausch zur Laufzeit
5. **Adapter** - Löst Kompatibilitätsprobleme zwischen Systemen

### Checkliste für Pattern-Implementierung

- [ ] **Problem erkannt** - Welches Pattern passt?
- [ ] **Interface definiert** - Gemeinsames Verhalten?
- [ ] **Konkrete Implementierungen** - Verschiedene Varianten?
- [ ] **Client-Code** - Wie wird das Pattern verwendet?
- [ ] **Fehlerbehandlung** - Was passiert bei Fehlern?
- [ ] **Dokumentation** - Ist der Code verständlich?

---

## Nächste Schritte

### Vertiefung
1. **Weitere Patterns** lernen:
   - Builder Pattern
   - Decorator Pattern
   - Facade Pattern
   - Template Method Pattern

2. **Pattern-Kombinationen**:
   - Factory + Singleton
   - Observer + Strategy
   - Adapter + Decorator

3. **Praxisprojekte**:
   - Mini-Shop mit mehreren Patterns
   - Event-System mit Observer
   - Zahlungssystem mit Strategy

### Ressourcen
- [Design Patterns - Gang of Four](https://en.wikipedia.org/wiki/Design_Patterns)
- [Refactoring Guru](https://refactoring.guru/design-patterns)
- [Java Design Patterns](https://java-design-patterns.com/)

---

## Rückkehr zum Übungsblatt

Zurück zu:
**[Java Grundlagen 5 – Übungsblatt: Design Patterns](5.md)**

