# Java Grundlagen 4 – Arrays & Collections

!!! abstract "Lernziele"
    Nach diesem Kapitel kannst du …

    - **Arrays** erstellen, initialisieren und durchlaufen.
    - **Collections Framework** (List, Set, Map) verstehen.
    - **Generics** für typsichere Collections verwenden.
    - **Wrapper-Klassen** und Autoboxing nutzen.
    - **Arrays und Collections** kombinieren.

---

## Einführung

**Arrays** und **Collections** sind Datenstrukturen zur Speicherung von Werten:
- **Arrays**: Feste Größe, gleicher Typ, schneller Zugriff
- **Collections**: Dynamische Größe, verschiedene Typen, zusätzliche Funktionen
- **Generics**: Typsicherheit ohne Casting

**Wichtige Fakten:**
- Arrays sind seit Java 1.0
- Collections Framework seit Java 1.2
- Generics seit Java 5
- Wrapper-Klassen für primitive Typen

---

## Arrays

### Erstellen
```java
// Deklaration und Initialisierung
int[] zahlen = {1, 2, 3, 4, 5};
String[] namen = {"Max", "Anna", "Tom"};

// Mit new-Operator
int[] zahlen2 = new int[5]; // [0, 0, 0, 0, 0]
String[] namen2 = new String[3]; // [null, null, null]

// Mit Werten füllen
int[] zahlen3 = new int[5];
for (int i = 0; i < zahlen3.length; i++) {
  zahlen3[i] = i * 2;
}
```

### Zugriff
```java
int[] zahlen = {10, 20, 30, 40, 50};

// Index (0-basiert)
System.out.println(zahlen[0]); // 10
System.out.println(zahlen[4]); // 50

// Ändern
zahlen[2] = 99;
System.out.println(zahlen[2]); // 99

// Länge
int laenge = zahlen.length; // 5

// Letztes Element
int letztes = zahlen[zahlen.length - 1]; // 50
```

### Iteration
```java
int[] zahlen = {1, 2, 3, 4, 5};

// For-Schleife
for (int i = 0; i < zahlen.length; i++) {
  System.out.println(zahlen[i]);
}

// For-Each (Enhanced For-Loop)
for (int zahl : zahlen) {
  System.out.println(zahl);
}

// While-Schleife
int i = 0;
while (i < zahlen.length) {
  System.out.println(zahlen[i]);
  i++;
}
```

### Arrays-Klasse (Utility)
```java
import java.util.Arrays;

int[] zahlen = {5, 2, 8, 1, 9};

// Sortieren
Arrays.sort(zahlen); // [1, 2, 5, 8, 9]

// Suchen (binäre Suche, muss sortiert sein)
int index = Arrays.binarySearch(zahlen, 5); // 2

// Kopieren
int[] kopie = Arrays.copyOf(zahlen, 3); // [1, 2, 5]

// Füllen
int[] leeres = new int[5];
Arrays.fill(leeres, -1); // [-1, -1, -1, -1, -1]

// In String umwandeln
String text = Arrays.toString(zahlen); // "[1, 2, 5, 8, 9]"
```

### Multidimensionale Arrays
```java
// 2D-Array (Matrix)
int[][] matrix = {
  {1, 2, 3},
  {4, 5, 6},
  {7, 8, 9}
};

// Zugriff
System.out.println(matrix[0][0]); // 1
System.out.println(matrix[2][2]); // 9

// Iteration
for (int i = 0; i < matrix.length; i++) {
  for (int j = 0; j < matrix[i].length; j++) {
    System.out.print(matrix[i][j] + " ");
  }
  System.out.println();
}
```

{{ task(file="tasks/04_00_07.yaml") }}

---

## Collections Framework

### Hierarchie
```
Collection
├── List (geordnet, wiederholbar)
│   ├── ArrayList
│   ├── LinkedList
│   └── Vector
├── Set (ungeordnet, einzigartig)
│   ├── HashSet
│   ├── LinkedHashSet
│   └── TreeSet
└── Queue (Warteschlange)
    ├── PriorityQueue
    └── ArrayDeque
```

### List-Implementierungen

#### ArrayList
```java
import java.util.ArrayList;
import java.util.List;

List<String> namen = new ArrayList<>();

// Hinzufügen
namen.add("Max");
namen.add("Anna");
namen.add("Tom");

// An Position einfügen
namen.add(1, "Lisa"); // [Max, Lisa, Anna, Tom]

// Zugriff
String name = namen.get(0); // "Max"

// Größe
int size = namen.size(); // 4

// Iteration
for (String n : namen) {
  System.out.println(n);
}

// Entfernen
namen.remove(1); // Lisa entfernt
namen.remove("Tom"); // Tom entfernt
```

#### LinkedList
```java
import java.util.LinkedList;

LinkedList<String> liste = new LinkedList<>();

// Queue-Operationen
liste.addFirst("Erstes");
liste.addLast("Letztes");
liste.add("Zwischen"); // Am Ende

String erstes = liste.removeFirst(); // Entfernt und gibt zurück
String letztes = liste.getLast();

// Deque-Operationen
liste.push("Auf den Stapel"); // Stack
liste.pop(); // Vom Stapel entfernen
```

#### Vector
```java
import java.util.Vector;

Vector<String> vektor = new Vector<>();

// Thread-sicher
vektor.add("Element");
String element = vektor.get(0);
```

### Set-Implementierungen

#### HashSet
```java
import java.util.HashSet;
import java.util.Set;

Set<Integer> zahlen = new HashSet<>();

// Einzigartige Werte
zahlen.add(1);
zahlen.add(2);
zahlen.add(1); // Wird ignoriert

System.out.println(zahlen.size()); // 2

// Iteration
for (Integer z : zahlen) {
  System.out.println(z);
}
```

#### TreeSet
```java
import java.util.TreeSet;

Set<Integer> sortierteZahlen = new TreeSet<>();

sortierteZahlen.add(5);
sortierteZahlen.add(3);
sortierteZahlen.add(8);
sortierteZahlen.add(1);

// Automatisch sortiert
for (Integer z : sortierteZahlen) {
  System.out.println(z); // 1, 3, 5, 8
}
```

### Map-Implementierungen

#### HashMap
```java
import java.util.HashMap;
import java.util.Map;

Map<String, Integer> alter = new HashMap<>();

// Einfügen
alter.put("Max", 25);
alter.put("Anna", 30);
alter.put("Tom", 20);

// Zugriff
Integer maxAlter = alter.get("Max"); // 25
Integer lisaAlter = alter.get("Lisa"); // null

// Prüfen
boolean exists = alter.containsKey("Max"); // true
boolean hasValue = alter.containsValue(25); // true

// Iteration
for (Map.Entry<String, Integer> entry : alter.entrySet()) {
  System.out.println(entry.getKey() + ": " + entry.getValue());
}
```

#### TreeMap
```java
import java.util.TreeMap;

Map<String, Integer> sortiertesAlter = new TreeMap<>();

sortiertesAlter.put("Max", 25);
sortiertesAlter.put("Anna", 30);
sortiertesAlter.put("Tom", 20);

// Automatisch nach Key sortiert
for (Map.Entry<String, Integer> entry : sortiertesAlter.entrySet()) {
  System.out.println(entry.getKey() + ": " + entry.getValue());
}
```

### Queue-Implementierungen

#### PriorityQueue
```java
import java.util.PriorityQueue;

PriorityQueue<Integer> prioritaet = new PriorityQueue<>();

prioritaet.add(5);
prioritaet.add(1);
prioritaet.add(3);

// Gibt kleinstes Element zurück
System.out.println(prioritaet.poll()); // 1
System.out.println(prioritaet.poll()); // 3
```

#### ArrayDeque
```java
import java.util.ArrayDeque;

ArrayDeque<String> deque = new ArrayDeque<>();

// Als Queue
deque.addLast("A");
deque.addLast("B");
System.out.println(deque.removeFirst()); // A

// Als Stack
deque.push("X");
deque.push("Y");
System.out.println(deque.pop()); // Y
```

---

## Generics

### Was sind Generics?
**Generics** ermöglichen typsichere Collections ohne Casting.

```java
// Ohne Generics (alt)
List liste = new ArrayList();
liste.add("Hallo");
String text = (String) liste.get(0); // Casting nötig

// Mit Generics (modern)
List<String> liste = new ArrayList<>();
liste.add("Hallo");
String text = liste.get(0); // Kein Casting nötig
```

### Typ-Parameter
```java
// Einfacher Typ
List<String> namen = new ArrayList<>();

// Komplexer Typ
Map<String, List<Integer>> daten = new HashMap<>();

// Wildcards
List<?> beliebig = new ArrayList<String>(); // Beliebiger Typ
List<? extends Number> zahlen = new ArrayList<Integer>(); // Number oder Subtyp
List<? super Integer> objekte = new ArrayList<Object>(); // Integer oder Supertyp
```

### Eigene Generics
```java
public class Box<T> {
  private T inhalt;

  public void setInhalt(T inhalt) {
    this.inhalt = inhalt;
  }

  public T getInhalt() {
    return inhalt;
  }
}

// Verwendung
Box<String> stringBox = new Box<>();
stringBox.setInhalt("Hallo");

Box<Integer> intBox = new Box<>();
intBox.setInhalt(42);
```

### Generics in Methoden
```java
public class Utils {
  // Generische Methode
  public static <T> List<T> erstelleListe(T... elemente) {
    List<T> liste = new ArrayList<>();
    for (T element : elemente) {
      liste.add(element);
    }
    return liste;
  }

  // Verwendung
  public static void main(String[] args) {
    List<String> namen = erstelleListe("Max", "Anna", "Tom");
    List<Integer> zahlen = erstelleListe(1, 2, 3, 4, 5);
  }
}
```

---

## Wrapper-Klassen & Autoboxing

### Wrapper-Klassen
```java
// Primitive Typen
int i = 10;
double d = 3.14;
boolean b = true;

// Wrapper-Klassen
Integer iObj = Integer.valueOf(10);
Double dObj = Double.valueOf(3.14);
Boolean bObj = Boolean.valueOf(true);

// Methoden
int wert = iObj.intValue();
double dWert = dObj.doubleValue();
```

### Autoboxing & Unboxing (Java 5+)
```java
// Autoboxing (Primitive → Wrapper)
Integer i = 10; // int → Integer
Double d = 3.14; // double → Double
Boolean b = true; // boolean → Boolean

// Unboxing (Wrapper → Primitive)
int iWert = i; // Integer → int
double dWert = d; // Double → double
boolean bWert = b; // Boolean → boolean

// In Collections
List<Integer> zahlen = new ArrayList<>();
zahlen.add(10); // Autoboxing
int wert = zahlen.get(0); // Unboxing
```

### Null-Sicherheit
```java
// Vorsicht: Null bei Unboxing
Integer i = null;
// int wert = i; // NullPointerException!

// Sicher prüfen
if (i != null) {
  int wert = i; // Sicher
}

// Optional (Java 8+)
import java.util.Optional;

Optional<Integer> opt = Optional.ofNullable(i);
int wert = opt.orElse(0); // 0 wenn null
```

---

## Arrays & Collections kombinieren

### Array zu List
```java
import java.util.Arrays;
import java.util.List;

// Array → List (nicht modifizierbar)
String[] array = {"A", "B", "C"};
List<String> list = Arrays.asList(array);

// Modifizierbare Liste
List<String> modifizierbar = new ArrayList<>(Arrays.asList(array));
modifizierbar.add("D"); // Erlaubt

// Stream (Java 8+)
List<String> streamList = Arrays.stream(array)
    .collect(Collectors.toList());
```

### List zu Array
```java
import java.util.List;

List<String> list = new ArrayList<>();
list.add("A");
list.add("B");

// Zu Array
String[] array = list.toArray(new String[0]);

// Mit spezifischer Größe
String[] array2 = list.toArray(new String[list.size()]);
```

### Sortierung
```java
import java.util.Collections;
import java.util.Comparator;

List<Integer> zahlen = new ArrayList<>();
zahlen.add(5);
zahlen.add(2);
zahlen.add(8);

// Natürliche Sortierung
Collections.sort(zahlen); // [2, 5, 8]

// Absteigend
Collections.sort(zahlen, Collections.reverseOrder());

// Mit Custom Comparator
zahlen.sort((a, b) -> b - a); // Absteigend
```

### Filter & Transformation
```java
import java.util.stream.Collectors;

List<String> namen = Arrays.asList("Max", "Anna", "Tom", "Lisa");

// Filter
List<String> mitA = namen.stream()
    .filter(n -> n.startsWith("A"))
    .collect(Collectors.toList());

// Transformation
List<Integer> laengen = namen.stream()
    .map(String::length)
    .collect(Collectors.toList());

// Sortierung
List<String> sortiert = namen.stream()
    .sorted()
    .collect(Collectors.toList());
```

{{ task(file="tasks/04_00_08.yaml") }}

---

## Praktische Beispiele

### Beispiel 1: Statistik mit Arrays
```java
public class Statistik {
  public static void main(String[] args) {
    int[] zahlen = {10, 25, 30, 45, 50, 65, 70, 85, 90, 100};

    // Summe
    int summe = 0;
    for (int z : zahlen) {
      summe += z;
    }

    // Durchschnitt
    double durchschnitt = (double) summe / zahlen.length;

    // Min/Max
    int min = Integer.MAX_VALUE;
    int max = Integer.MIN_VALUE;
    for (int z : zahlen) {
      if (z < min) min = z;
      if (z > max) max = z;
    }

    System.out.println("Summe: " + summe);
    System.out.println("Durchschnitt: " + durchschnitt);
    System.out.println("Min: " + min);
    System.out.println("Max: " + max);
  }
}
```

### Beispiel 2: Wörterbuch mit Map
```java
import java.util.HashMap;
import java.util.Map;

public class Woerterbuch {
  private Map<String, String> deutschEnglisch = new HashMap<>();

  public void hinzufuegen(String deutsch, String englisch) {
    deutschEnglisch.put(deutsch, englisch);
  }

  public String uebersetze(String wort) {
    return deutschEnglisch.getOrDefault(wort, "Nicht gefunden");
  }

  public void alleAnzeigen() {
    for (Map.Entry<String, String> entry : deutschEnglisch.entrySet()) {
      System.out.println(entry.getKey() + " = " + entry.getValue());
    }
  }

  public static void main(String[] args) {
    Woerterbuch wb = new Woerterbuch();
    wb.hinzufuegen("Haus", "house");
    wb.hinzufuegen("Baum", "tree");
    wb.hinzufuegen("Auto", "car");

    System.out.println(wb.uebersetze("Haus")); // house
    wb.alleAnzeigen();
  }
}
```

### Beispiel 3: Shopping-Korb mit List
```java
import java.util.ArrayList;
import java.util.List;

public class ShoppingKorb {
  private List<String> produkte = new ArrayList<>();

  public void hinzufuegen(String produkt) {
    produkte.add(produkt);
  }

  public void entfernen(String produkt) {
    produkte.remove(produkt);
  }

  public void anzeigen() {
    if (produkte.isEmpty()) {
      System.out.println("Korb ist leer");
      return;
    }

    System.out.println("Korb-Inhalt:");
    for (int i = 0; i < produkte.size(); i++) {
      System.out.println((i + 1) + ". " + produkte.get(i));
    }
  }

  public int anzahl() {
    return produkte.size();
  }

  public static void main(String[] args) {
    ShoppingKorb korb = new ShoppingKorb();
    korb.hinzufuegen("Milch");
    korb.hinzufuegen("Brot");
    korb.hinzufuegen("Eier");

    korb.anzeigen();
    System.out.println("Anzahl Produkte: " + korb.anzahl());

    korb.entfernen("Brot");
    korb.anzeigen();
  }
}
```

---

## Häufige Fehler & Best Practices

### Fehler 1: IndexOutOfBoundsException
```java
// ❌ Falsch (Index zu groß)
int[] zahlen = {1, 2, 3};
System.out.println(zahlen[3]); // Exception!

// ✅ Gut (Prüfen)
if (index >= 0 && index < zahlen.length) {
  System.out.println(zahlen[index]);
}
```

### Fehler 2: NullPointerException bei Collections
```java
// ❌ Falsch (null in Collection)
List<String> liste = new ArrayList<>();
liste.add(null);
String text = liste.get(0).toUpperCase(); // NullPointerException!

// ✅ Gut (Prüfen)
String text = liste.get(0);
if (text != null) {
  text.toUpperCase();
}
```

### Fehler 3: Falsche Collection gewählt
```java
// ❌ Schlecht (List für einzigartige Werte)
List<String> namen = new ArrayList<>();
namen.add("Max");
namen.add("Max"); // Erlaubt, aber falsch

// ✅ Gut (Set für einzigartige Werte)
Set<String> namen = new HashSet<>();
namen.add("Max");
namen.add("Max"); // Wird ignoriert
```

### Best Practices
1. **Richtige Collection** wählen (List, Set, Map)
2. **Generics** immer verwenden
3. **Wrapper-Klassen** mit Vorsicht (Null-Checks)
4. **For-Each** statt Index-Schleifen
5. **Collections-Klassen** nutzen (sort, filter, etc.)
6. **Stream API** für komplexe Operationen

---

## Zusammenfassung & Checkliste

### Wichtige Konzepte
- ✅ **Arrays**: Feste Größe, gleicher Typ, schneller Zugriff
- ✅ **Collections**: Dynamisch, verschiedene Typen, zusätzliche Funktionen
- ✅ **Generics**: Typsicherheit ohne Casting
- ✅ **Wrapper-Klassen**: Primitive → Objekt (Autoboxing)
- ✅ **Utility-Klassen**: Arrays, Collections, Streams

### Checkliste für Datenstrukturen
- [ ] Richtige Collection gewählt
- [ ] Generics korrekt verwendet
- [ ] Null-Checks bei Wrapper-Klassen
- [ ] For-Each für Iteration
- [ ] Collections-Utility-Klassen genutzt
- [ ] Stream API für komplexe Operationen

---

## Nächste Schritte

Nachdem du diese Grundlagen beherrschst:
1. **Streams & Lambda** - Funktionale Programmierung
2. **Exceptions** - Fehlerbehandlung
3. **Date/Time API** - Datum und Zeit
4. **File I/O** - Dateizugriff

**Übungen:**
- [Erste Aufgabe in Java](https://info-wsf.de/uebungsaufgaben-erste-aufgaben-in-java/)

**Empfohlene Ressourcen:**
- [Oracle Java Collections](https://docs.oracle.com/javase/tutorial/collections/)
- [Java Collections Framework](https://www.baeldung.com/java-collections)
- [JavaRanch Collections](https://coderanch.com/wiki/660256-Collections)
