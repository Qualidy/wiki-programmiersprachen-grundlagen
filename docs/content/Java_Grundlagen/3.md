# Java Grundlagen 3 – Methoden & Funktionen

!!! abstract "Lernziele"
    Nach diesem Kapitel kannst du …

    - **Methoden** deklarieren und aufrufen.
    - **Parameter** und **Rückgabewerte** verstehen.
    - **Methoden-Überladung** (Overloading) anwenden.
    - **Rekursion** für komplexe Probleme nutzen.
    - **Varargs** für flexible Parameterlisten.

---

## Einführung

**Methoden** sind wiederverwendbare Code-Blöcke:
- **Organisation**: Teilen von Code in logische Einheiten
- **Wiederverwendung**: Einmal definieren, mehrfach verwenden
- **Wartbarkeit**: Änderungen an einer Stelle
- **Lesbarkeit**: Klarere Struktur

**Wichtige Fakten:**
- Methoden gehören zu Klassen (in Java)
- Jede Methode hat einen **Modifizierer**, **Rückgabetyp**, **Namen** und **Parameter**
- Die **Signatur** (Name + Parameter) identifiziert eine Methode
- **Overloading**: Gleicher Name, unterschiedliche Parameter

---

## Methoden-Grundlagen

### Syntax
```java
// Modifizierer Rückgabetyp Methodenname(Parameterliste) {
//   // Methodenkörper
//   return wert; // wenn Rückgabetyp nicht void
// }

public int addiere(int a, int b) {
  int ergebnis = a + b;
  return ergebnis;
}
```

### Modifizierer
```java
// Öffentlich (überall zugreifbar)
public void öffentlicheMethode() { }

// Privat (nur in dieser Klasse)
private void privateMethode() { }

// Protected (Klasse und Unterklassen)
protected void protectedMethode() { }

// Ohne Modifizierer (Package-Private)
void packagePrivateMethode() { }

// Static (Klassen-Methode)
public static void statischeMethode() { }

// Final (nicht überschreibbar)
public final void finaleMethode() { }
```

### Rückgabetypen
```java
// void (kein Rückgabewert)
public void sageHallo() {
  System.out.println("Hallo!");
}

// Primitiv
public int gibZahl() {
  return 42;
}

// Objekt
public String gibName() {
  return "Max";
}

// Null
public String gibOptional() {
  return null; // Erlaubt für Objekte
}
```

### Parameter
```java
// Einfache Parameter
public int addiere(int a, int b) {
  return a + b;
}

// Mehrere Parameter
public String formatiere(String name, int alter, String stadt) {
  return name + " (" + alter + ") aus " + stadt;
}

// Objekt-Parameter
public void speichereBenutzer(Benutzer benutzer) {
  // ...
}
```

{{ task(file="tasks/04_00_05.yaml") }}

---

## Parameter-Übertragung

### Wertepassung (Primitives)
```java
public class ParameterTest {
  public static void main(String[] args) {
    int x = 10;
    aendereWert(x); // Wert wird kopiert
    System.out.println(x); // 10 (unverändert)
  }

  public static void aendereWert(int zahl) {
    zahl = 20; // Ändert nur die Kopie
  }
}
```

### Referenzpassung (Objekte)
```java
public class ParameterTest {
  public static void main(String[] args) {
    Person p = new Person("Max");
    aendereName(p); // Referenz wird kopiert
    System.out.println(p.name); // "Anna" (verändert!)
  }

  public static void aendereName(Person person) {
    person.name = "Anna"; // Ändert das Original-Objekt
  }
}
```

### Unveränderliche Objekte
```java
public class ParameterTest {
  public static void main(String[] args) {
    String text = "Hallo";
    aendereText(text); // Referenz wird kopiert
    System.out.println(text); // "Hallo" (unverändert!)
  }

  public static void aendereText(String t) {
    t = "Welt"; // Erzeugt neues Objekt, ändert nicht Original
  }
}
```

---

## Methoden-Überladung (Overloading)

### Grundprinzip
```java
public class Calculator {
  // Gleicher Name, unterschiedliche Parameter

  public int addiere(int a, int b) {
    return a + b;
  }

  public double addiere(double a, double b) {
    return a + b;
  }

  public int addiere(int a, int b, int c) {
    return a + b + c;
  }

  public String addiere(String a, String b) {
    return a + b;
  }
}
```

### Wann Overloading?
```java
// Konstruktoren
public class Person {
  private String name;
  private int alter;

  public Person(String name) {
    this.name = name;
    this.alter = 0;
  }

  public Person(String name, int alter) {
    this.name = name;
    this.alter = alter;
  }
}

// Verwendung
Person p1 = new Person("Max");
Person p2 = new Person("Anna", 25);
```

### Best Practices
```java
public class Logger {
  // Gut: Klare Namenskonvention
  public void log(String message) {
    System.out.println(message);
  }

  public void log(String message, int level) {
    System.out.println("[" + level + "] " + message);
  }

  public void log(String message, Throwable error) {
    System.out.println(message + ": " + error.getMessage());
  }

  // Schlecht: Zu viele Überladungen, unklar
  public void log(Object obj) { /* ... */ }
}
```

---

## Varargs (Variable Argument List)

### Syntax
```java
public class Summe {
  // Varargs mit ...
  public int summe(int... zahlen) {
    int ergebnis = 0;
    for (int zahl : zahlen) {
      ergebnis += zahl;
    }
    return ergebnis;
  }

  // Verwendung
  public static void main(String[] args) {
    Summe s = new Summe();
    System.out.println(s.summe(1, 2, 3)); // 6
    System.out.println(s.summe(1, 2, 3, 4, 5)); // 15
    System.out.println(s.summe()); // 0
  }
}
```

### Varargs mit anderen Parametern
```java
public class Logger {
  // Varargs muss der letzte Parameter sein
  public void log(String level, String... messages) {
    for (String msg : messages) {
      System.out.println("[" + level + "] " + msg);
    }
  }

  // Verwendung
  public static void main(String[] args) {
    Logger logger = new Logger();
    logger.log("INFO", "Start", "Verarbeite", "Ende");
  }
}
```

### Varargs mit Objekten
```java
public class Formatierer {
  public String formatiere(String muster, Object... werte) {
    return String.format(muster, werte);
  }

  // Verwendung
  public static void main(String[] args) {
    Formatierer f = new Formatierer();
    System.out.println(f.formatiere("Hallo %s, du bist %d Jahre alt", "Max", 25));
  }
}
```

---

## Rekursion

### Grundprinzip
```java
public class Rekursion {
  // Fakultät
  public int fakultaet(int n) {
    if (n <= 1) {
      return 1; // Basisfall
    }
    return n * fakultaet(n - 1); // Rekursiver Aufruf
  }

  // Verwendung
  public static void main(String[] args) {
    Rekursion r = new Rekursion();
    System.out.println(r.fakultaet(5)); // 120
  }
}
```

### Fibonacci-Folge
```java
public class Fibonacci {
  public int fib(int n) {
    if (n <= 1) {
      return n; // Basisfall: fib(0)=0, fib(1)=1
    }
    return fib(n - 1) + fib(n - 2); // Rekursiv
  }

  // Mit Memoization (Optimierung)
  private int[] cache;

  public int fibMemo(int n) {
    if (cache == null) {
      cache = new int[n + 1];
    }

    if (n <= 1) {
      return n;
    }

    if (cache[n] != 0) {
      return cache[n]; // Aus Cache
    }

    cache[n] = fibMemo(n - 1) + fibMemo(n - 2);
    return cache[n];
  }
}
```

### Binäre Suche (Rekursiv)
```java
public class BinaereSuche {
  public int suche(int[] array, int links, int rechts, int ziel) {
    if (links > rechts) {
      return -1; // Nicht gefunden
    }

    int mitte = links + (rechts - links) / 2;

    if (array[mitte] == ziel) {
      return mitte; // Gefunden
    }

    if (array[mitte] > ziel) {
      return suche(array, links, mitte - 1, ziel); // Links suchen
    } else {
      return suche(array, mitte + 1, rechts, ziel); // Rechts suchen
    }
  }
}
```

### Tail-Recursion (Optimierung)
```java
public class TailRecursion {
  // Nicht Tail-Recursion
  public int summe(int n) {
    if (n == 0) return 0;
    return n + summe(n - 1); // Addiert nach dem Rücklauf
  }

  // Tail-Recursion (kann optimiert werden)
  public int summeTail(int n, int akkumulator) {
    if (n == 0) return akkumulator;
    return summeTail(n - 1, akkumulator + n); // Addiert vor dem Rücklauf
  }

  // Wrapper
  public int summe(int n) {
    return summeTail(n, 0);
  }
}
```

{{ task(file="tasks/04_00_06.yaml") }}

---

## Statische Methoden

### Klassen-Methoden
```java
public class MathHelper {
  // Static: Gehört der Klasse, nicht einer Instanz
  public static int addiere(int a, int b) {
    return a + b;
  }

  public static double quadrat(double x) {
    return x * x;
  }

  // Verwendung ohne Objekt
  public static void main(String[] args) {
    int ergebnis = MathHelper.addiere(5, 3); // 8
    double q = MathHelper.quadrat(4.0); // 16.0
  }
}
```

### Static Factory Methods
```java
public class Person {
  private String name;
  private int alter;

  private Person(String name, int alter) {
    this.name = name;
    this.alter = alter;
  }

  // Static Factory Methods
  public static Person erzeugeErwachsenen(String name) {
    return new Person(name, 18);
  }

  public static Person erzeugeKind(String name) {
    return new Person(name, 0);
  }

  public static Person ausString(String text) {
    String[] parts = text.split(",");
    return new Person(parts[0], Integer.parseInt(parts[1]));
  }

  // Verwendung
  public static void main(String[] args) {
    Person p1 = Person.erzeugeErwachsenen("Max");
    Person p2 = Person.ausString("Anna,25");
  }
}
```

---

## Methoden als Parameter

### Lambda-Ausdrücke
```java
import java.util.function.Function;

public class MethodenAlsParameter {
  // Methode, die eine Funktion als Parameter nimmt
  public static int verarbeite(int zahl, Function<Integer, Integer> transformer) {
    return transformer.apply(zahl);
  }

  public static void main(String[] args) {
    // Lambda als Parameter
    int quadrat = verarbeite(5, x -> x * x);
    int verdoppelt = verarbeite(5, x -> x * 2);

    // Methoden-Referenz
    int erhoeht = verarbeite(5, MethodenAlsParameter::erhoehen);
  }

  public static int erhoehen(int x) {
    return x + 10;
  }
}
```

### Callback-Pattern
```java
public class CallbackExample {
  // Interface für Callback
  public interface Callback {
    void onResult(String result);
    void onError(String error);
  }

  // Methode mit Callback
  public void ladeDatenAsync(Callback callback) {
    try {
      // Simuliere asynchrone Operation
      String result = "Daten geladen";
      callback.onResult(result);
    } catch (Exception e) {
      callback.onError(e.getMessage());
    }
  }

  // Verwendung
  public static void main(String[] args) {
    CallbackExample example = new CallbackExample();

    example.ladeDatenAsync(new Callback() {
      @Override
      public void onResult(String result) {
        System.out.println("Erfolg: " + result);
      }

      @Override
      public void onError(String error) {
        System.out.println("Fehler: " + error);
      }
    });
  }
}
```

---

## Praktische Beispiele

### Beispiel 1: Utility-Klasse
```java
public class StringUtils {
  // Private Konstruktor verhindert Instanziierung
  private StringUtils() { }

  public static boolean istLeer(String text) {
    return text == null || text.trim().isEmpty();
  }

  public static String kapitalisiere(String text) {
    if (istLeer(text)) return text;
    return text.substring(0, 1).toUpperCase() + text.substring(1).toLowerCase();
  }

  public static String[] splitLines(String text) {
    if (istLeer(text)) return new String[0];
    return text.split("\\r?\\n");
  }

  // Verwendung
  public static void main(String[] args) {
    String text = "hallo welt";
    System.out.println(StringUtils.kapitalisiere(text)); // "Hallo Welt"
  }
}
```

### Beispiel 2: Calculator mit Overloading
```java
public class Calculator {
  // Addition
  public int add(int a, int b) {
    return a + b;
  }

  public double add(double a, double b) {
    return a + b;
  }

  public int add(int... zahlen) {
    int sum = 0;
    for (int z : zahlen) {
      sum += z;
    }
    return sum;
  }

  // Multiplikation
  public int multiply(int a, int b) {
    return a * b;
  }

  public double multiply(double a, double b) {
    return a * b;
  }

  // Potenz
  public int power(int basis, int exponent) {
    if (exponent == 0) return 1;
    if (exponent == 1) return basis;
    return basis * power(basis, exponent - 1); // Rekursiv
  }

  public static void main(String[] args) {
    Calculator calc = new Calculator();
    System.out.println(calc.add(1, 2, 3, 4, 5)); // 15
    System.out.println(calc.power(2, 3)); // 8
  }
}
```

### Beispiel 3: Rekursiver Baum-Scan
```java
import java.io.File;

public class FileScanner {
  // Rekursives Verzeichnis-Scannen
  public void scan(File directory, int depth) {
    if (!directory.exists() || !directory.isDirectory()) {
      return;
    }

    File[] files = directory.listFiles();
    if (files == null) return;

    for (File file : files) {
      // Einrücken für Tiefe
      String indent = "  ".repeat(depth);
      System.out.println(indent + file.getName());

      if (file.isDirectory()) {
        scan(file, depth + 1); // Rekursiver Aufruf
      }
    }
  }

  public static void main(String[] args) {
    FileScanner scanner = new FileScanner();
    scanner.scan(new File("C:/temp"), 0);
  }
}
```

---

## Häufige Fehler & Best Practices

### Fehler 1: Zu viele Parameter
```java
// ❌ Schlecht (zu viele Parameter)
public void erstelleUser(String name, String email, int alter, String stadt, String land, String plz, String strasse) { }

// ✅ Gut (Objekt als Parameter)
public void erstelleUser(UserData data) { }

// Oder: Builder-Pattern
public UserBuilder withName(String name) { /* ... */ }
```

### Fehler 2: Keine Rückgabewerte
```java
// ❌ Schlecht (void, aber ändert Parameter)
public void berechne(int a, int b) {
  int ergebnis = a + b; // Wird nirgendwo verwendet
}

// ✅ Gut (Rückgabewert)
public int berechne(int a, int b) {
  return a + b;
}
```

### Fehler 3: Zu komplexe Methoden
```java
// ❌ Schlecht (zu lang, mehrere Aufgaben)
public void verarbeiteDaten() {
  // 50 Zeilen Code...
}

// ✅ Gut (unterteilt in kleine Methoden)
public void verarbeiteDaten() {
  validateInput();
  loadData();
  processData();
  saveResults();
}
```

### Best Practices
1. **Kleine Methoden** (maximal 20 Zeilen)
2. **Eine Aufgabe** pro Methode
3. **Klare Namen** (selbsterklärend)
4. **Keine Seiteneffekte** (bei möglichkeit)
5. **Dokumentation** (JSDoc/Kommentare)
6. **Parameter-Validierung** am Anfang
7. **Rückgabewerte** immer nutzen

---

## Zusammenfassung & Checkliste

### Wichtige Konzepte
- ✅ **Methoden-Syntax**: Modifizierer, Rückgabetyp, Name, Parameter
- ✅ **Parameter**: Wertepassung vs. Referenzpassung
- ✅ **Overloading**: Gleicher Name, unterschiedliche Parameter
- ✅ **Varargs**: Flexible Parameterlisten (...)
- ✅ **Rekursion**: Selbstaufrufende Methoden
- ✅ **Static**: Klassen-Methoden
- ✅ **Callbacks**: Methoden als Parameter

### Checkliste für Methoden
- [ ] Klare Namenskonventionen
- [ ] Maximal 20 Zeilen pro Methode
- [ ] Eine Aufgabe pro Methode
- [ ] Parameter validiert
- [ ] Rückgabewerte genutzt
- [ ] Dokumentation (JSDoc)
- [ ] Keine Seiteneffekte

---

## Nächste Schritte

Nachdem du diese Grundlagen beherrschst:
1. **Exceptions** - Fehlerbehandlung
2. **Collections** - Listen, Sets, Maps
3. **Streams** - Funktionale Programmierung
4. **Lambdas** - Moderne Syntax

**Empfohlene Ressourcen:**
- [Oracle Java Tutorials - Methods](https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html)
- [JavaRanch - Methods](https://coderanch.com/wiki/660254-Methods)
- [MDN Java Methods](https://developer.mozilla.org/de/docs/Web/Java/Methods)
