# Java Grundlagen 5 â€“ Ãœbungsblatt: Design Patterns

!!! abstract "Lernziele"
    Nach diesem Kapitel kannst du â€¦

    - **Design Patterns** verstehen und anwenden
    - **Singleton Pattern** implementieren
    - **Factory Pattern** zur Objekterstellung nutzen
    - **Observer Pattern** fÃ¼r Benachrichtigungen verwenden
    - **Strategy Pattern** fÃ¼r Algorithmen austauschen
    - **Adapter Pattern** fÃ¼r KompatibilitÃ¤t nutzen

---

## EinfÃ¼hrung in Design Patterns

### Was sind Design Patterns?

**Design Patterns** sind bewÃ¤hrte LÃ¶sungsansÃ¤tze fÃ¼r wiederkehrende Probleme in der Softwareentwicklung. Sie sind:

- **Wiederverwendbare LÃ¶sungen** fÃ¼r hÃ¤ufige Probleme
- **Best Practices** aus der Industrie
- **SprachunabhÃ¤ngig** (gilt fÃ¼r viele Programmiersprachen)
- **Dokumentierte Erfahrungen** erfahrener Entwickler

### Kategorien von Design Patterns

**Erzeugungsmuster (Creational Patterns):**
- Singleton, Factory, Builder, Prototype
- **Ziel:** Objekterstellung kontrollieren

**Strukturmuster (Structural Patterns):**
- Adapter, Decorator, Facade, Proxy
- **Ziel:** Klassen und Objekte zusammenfÃ¼gen

**Verhaltensmuster (Behavioral Patterns):**
- Observer, Strategy, Command, Template Method
- **Ziel:** Kommunikation zwischen Objekten

---

## Ãœbungsaufgaben

### Aufgabe 1: Singleton Pattern (ğŸŒ¶ğŸŒ¶)

Implementiere das **Singleton Pattern** fÃ¼r eine Datenbankverbindung.

**Anforderungen:**
- Klasse `DatabaseConnection` soll nur eine Instanz haben
- Privater Konstruktor verhindert direkte Instanziierung
- `getInstance()`-Methode gibt die einzige Instanz zurÃ¼ck
- `connect()`-Methode simuliert die Verbindung

{{ task(file="tasks/04_00_05.yaml") }}

---

### Aufgabe 2: Factory Pattern (ğŸŒ¶ğŸŒ¶ğŸŒ¶)

Implementiere das **Factory Pattern** fÃ¼r Fahrzeug-Erstellung.

**Anforderungen:**
- Abstrakte Klasse `Fahrzeug` mit `fahre()`-Methode
- Konkrete Klassen `Auto` und `Motorrad`
- Factory-Klasse `FahrzeugFactory` zur Erstellung
- Client verwendet Factory, ohne konkrete Klassen zu kennen

{{ task(file="tasks/04_00_06.yaml") }}

---

### Aufgabe 3: Observer Pattern (ğŸŒ¶ğŸŒ¶ğŸŒ¶)

Implementiere das **Observer Pattern** fÃ¼r ein Wetter-Benachrichtigungssystem.

**Anforderungen:**
- Interface `Observer` mit `update()`-Methode
- Abstrakte Klasse `Subject` fÃ¼r Verwaltung der Observer
- Konkrete Klasse `WetterStation` als Subject
- Konkrete Observer: `Smartphone` und `Webseite`
- Observer kÃ¶nnen dynamisch hinzugefÃ¼gt/entfernt werden

{{ task(file="tasks/04_00_07.yaml") }}

---

### Aufgabe 4: Strategy Pattern (ğŸŒ¶ğŸŒ¶ğŸŒ¶)

Implementiere das **Strategy Pattern** fÃ¼r Zahlungsmethoden.

**Anforderungen:**
- Interface `Zahlungsstrategie` mit `zahle()`-Methode
- Drei konkrete Strategien: `Kreditkarte`, `PayPal`, `Barzahlung`
- Kontext-Klasse `Warenkorb` mit wechselbarer Strategie
- Strategie kann zur Laufzeit ausgetauscht werden

{{ task(file="tasks/04_00_08.yaml") }}

---

### Aufgabe 5: Adapter Pattern (ğŸŒ¶ğŸŒ¶)

Implementiere das **Adapter Pattern** fÃ¼r Datenbank-KompatibilitÃ¤t.

**Anforderungen:**
- Alte Klasse `AlteDatenbank` mit `holeDaten()`-Methode
- Neues Interface `NeueDatenquelle` mit `ladeDaten()`-Methode
- Adapter `DatenbankAdapter` Ã¼bersetzt Aufrufe
- Client verwendet neues Interface, ohne alte Klasse zu kennen

{{ task(file="tasks/04_00_09.yaml") }}

---

## Vergleich der Patterns

| Pattern | Zweck | Wann verwenden? |
|---------|-------|-----------------|
| **Singleton** | Nur eine Instanz | Globale Ressourcen, Logging, Konfiguration |
| **Factory** | Objekterstellung | Flexible Erstellung von Objekten |
| **Observer** | Benachrichtigungen | Publish-Subscribe, Event-Handling |
| **Strategy** | Algorithmen austauschen | Verschiedene Zahlungsmethoden, Sortieralgorithmen |
| **Adapter** | KompatibilitÃ¤t | Integration alter Systeme, API-Anpassung |

---

## Best Practices fÃ¼r Design Patterns

### âœ… Do's
- **Verstehe das Problem** bevor du ein Pattern anwendest
- **Ãœbertreibe nicht** - nicht jedes Problem braucht ein Pattern
- **Dokumentiere** warum du ein Pattern gewÃ¤hlt hast
- **Teste** die Implementierung grÃ¼ndlich

### âŒ Don'ts
- **Pattern fÃ¼r Pattern's sake** - nur wenn es einen Nutzen hat
- **Zu komplex** - einfache LÃ¶sungen bevorzugen
- **Vergessene Anpassungen** - passe das Pattern an dein Problem an

---

## Zusammenfassung & Checkliste

### Wichtige Konzepte
- âœ… **Design Patterns** sind bewÃ¤hrte LÃ¶sungsansÃ¤tze
- âœ… **Singleton** sichert eine einzige Instanz
- âœ… **Factory** kapselt Objekterstellung
- âœ… **Observer** implementiert Publish-Subscribe
- âœ… **Strategy** erlaubt Algorithmen-Austausch
- âœ… **Adapter** ermÃ¶glicht KompatibilitÃ¤t

### Checkliste
- [ ] Singleton Pattern verstanden und implementiert
- [ ] Factory Pattern fÃ¼r flexible Erstellung verwendet
- [ ] Observer Pattern fÃ¼r Benachrichtigungen genutzt
- [ ] Strategy Pattern fÃ¼r Algorithmen-Austausch angewendet
- [ ] Adapter Pattern fÃ¼r KompatibilitÃ¤t implementiert
- [ ] Unterschiede zwischen den Patterns erkannt

---

## NÃ¤chste Schritte

Nachdem du diese Ãœbungen gelÃ¶st hast:

1. **LÃ¶sungsblatt** Ã¼berprÃ¼fen und verstehen
2. **Weitere Patterns** lernen (Builder, Decorator, Facade)
3. **Praxisprojekt** mit mehreren Patterns kombinieren
4. **Refactoring** bestehender Code mit Patterns verbessern

**Empfohlene Ressourcen:**
- [Design Patterns - Gang of Four](https://en.wikipedia.org/wiki/Design_Patterns)
- [Refactoring Guru - Design Patterns](https://refactoring.guru/design-patterns)
- [Java Design Patterns](https://java-design-patterns.com/)

---

## LÃ¶sungsblatt

FÃ¼r die LÃ¶sungen zu diesen Ãœbungen, siehe:
**[Java Grundlagen 6 â€“ LÃ¶sungsblatt: Design Patterns](6.md)**

